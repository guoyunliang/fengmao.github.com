<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>无网不剩</title>
 <link href="http://blog.leezhong.com/atom.xml" rel="self"/>
 <link href="http://blog.leezhong.com/"/>
 <updated>2012-09-18T10:53:06+08:00</updated>
 <id>http://blog.leezhong.com/</id>
 <author>
   <name>lzyy</name>
   <email>healdream@gmail.com</email>
 </author>

 
 <entry>
   <title>弱符号和别名</title>
   <link href="http://blog.leezhong.com/programming/2012/09/12/weak-alias.html"/>
   <updated>2012-09-12T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/09/12/weak-alias</id>
   <content type="html">&lt;p&gt;&lt;em&gt;王聪的&lt;a href=&quot;http://wangcong.org/blog/archives/262&quot;&gt;强符号，弱符号&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;弱符号(weak symbol)是gcc的特性，比如给foo加上__attribute__((weak))，foo实际上可以不存在，这样也不阻止程序正确编译链接。&lt;br/&gt;
Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;上面的代码中，在weak_test.c中即使不定义foo，程序也能正确编译链接执行。如果定义了foo，打印“Hello”。&lt;/p&gt;

&lt;p&gt;至于linker处理弱符号的细节，没去了解。看起来ld在链接时，会做一个检查，如果没有foo，也不报错。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;gcc还提供一个特性：weak_alias，它为一个符号定义一个别名，直接看例子：&lt;br/&gt;
Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;bar.c中写了两种weak alias的实现，方式一就是glibc的做法，它实际上等价与方式二。&lt;br/&gt;
在这个例子中，bar是_bar的别名，main里面调用bar的时候，实际上就是调用_bar.&lt;br/&gt;
weak在这里的含义：bar这个别名是weak symbol，于是可以重新定义bar，就像在weakalias.c中注释的代码那样。&lt;/p&gt;

&lt;p&gt;glibc多处用到weak_alias，比如socket函数定义为__socket的别名，weak_alias(__socket, socket)，但__socket几乎是一个空函数，显然不是我们需要的socket函数逻辑。&lt;br/&gt;
实际的socket函数是以汇编代码的方式，重新定义在glibc/sys-deps/unix/sysv/linux/i386/socket.S中的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>内核network stack</title>
   <link href="http://blog.leezhong.com/linux/2012/09/08/kernel-networking-stack.html"/>
   <updated>2012-09-08T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/linux/2012/09/08/kernel-networking-stack</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Peripheral_device&quot;&gt;外设&lt;/a&gt;一般都有&lt;a href=&quot;http://en.wikipedia.org/wiki/Computer_port_(hardware)&quot;&gt;硬件端口/接口&lt;/a&gt;，通过接口和主机相连。&lt;br/&gt;
设备有对应的驱动，OS通过设备驱动访问设备。&lt;br/&gt;
大多数硬件会有几个&lt;a href=&quot;http://en.wikipedia.org/wiki/Hardware_register&quot;&gt;硬件寄存器&lt;/a&gt;，比如CPU的硬件寄存器称之为&lt;a href=&quot;http://en.wikipedia.org/wiki/Processor_register&quot;&gt;Processor register&lt;/a&gt;，就是C语言中的“寄存器变量”指代的寄存器。&lt;br/&gt;
OS通过硬件端口连接外设，通过读写外设的硬件寄存器控制外设。&lt;em&gt;(&lt;a href=&quot;http://lwn.net/images/pdf/LDD3/ch09.pdf&quot;&gt;ldd ch9 &quot;communicating with hardware&quot;&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;OS有两种访问硬件寄存器的方式：&lt;a href=&quot;http://en.wikipedia.org/wiki/Memory-mapped_I/O&quot;&gt;memory-mapped I/O&lt;/a&gt;和Port-mapped I/O。&lt;br/&gt;
memory-mapped I/O指用同样的寻址总线寻址内存和I/O设备，即把内存和I/O设备放在同一地址空间。&lt;br/&gt;
port-mapped I/O需要用特殊的CPU指令访问外设，如inl、inw、outl、outw等。&lt;/p&gt;

&lt;p&gt;外设有两种类型：&lt;a href=&quot;http://zh.wikipedia.org/wiki/ISA&quot;&gt;ISA&lt;/a&gt;和PCI(&lt;a href=&quot;http://net.pku.edu.cn/~yhf/lyceum/linuxK/dd/pci.html&quot;&gt;1&lt;/a&gt;,&lt;a href=&quot;http://www.csie.nctu.edu.tw/~tcwu/doc/Linux/Kernel/chapter6/chapter6.htm&quot;&gt;2&lt;/a&gt;)。除了特殊工业用途外，ISA设备已经不再使用了，而且现在的主板都不带ISA接口(&lt;a href=&quot;http://zh.wikipedia.org/wiki/ISA#.E5.BD.93.E5.89.8D.E5.BA.94.E7.94.A8&quot;&gt;ref&lt;/a&gt;)。&lt;/p&gt;

&lt;p&gt;外设和CPU、内存等的关系：&lt;br/&gt;
&lt;img src=&quot;/images/osarch.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;port-mapped I/O&lt;/strong&gt;&lt;br/&gt;
I/O ports是驱动程序和设备之间的通信方式--至少在部分时间是这样。&lt;br/&gt;
使用I/O ports之前，驱动程序需要先申请，内核提供函数request_region，驱动通过该函数声明自己需要操作的端口。&lt;br/&gt;
/proc/ioports记录系统所有的端口分配。&lt;br/&gt;
操作端口可以使用inb、outb之类的函数，内核态用户态都可以直接操作端口。&lt;br/&gt;
端口操作需要处理一个问题：CPU从总线传输数据的速度比外设快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;memory-mapped I/O&lt;/strong&gt;&lt;br/&gt;
外设会有硬件寄存器，也会有自己的内存空间(&lt;a href=&quot;http://tldp.org/LDP/tlk/dd/pci.html&quot;&gt;PCI Address Spaces&lt;/a&gt;)。和设备通信的另一种方式——同时也是主要方式——是把外设的寄存器和独立内存映射到主存所在的地址空间。此时外设寄存器和独立内存都称为I/O memory，因为二者对软件来说是透明的。&lt;br/&gt;
I/O内存仅仅是类似于主存RAM的一个区域，这种内存有很多用途，比如存放视频数据或以太网数据包，也可以用来实现类似于I/O端口的设备寄存器。&lt;br/&gt;
访问I/O内存可以通过页表，也可以不通过页表。内核提供了request_mem_region等函数操作I/O内存。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;PCI驱动&lt;/strong&gt;(详见ldd ch12)&lt;/p&gt;

&lt;p&gt;PCI设备上电时，硬件保持未激活状态，此时硬件只响应配置任务。&lt;br/&gt;
每个PCI主板配备有能处理PCI的固件，如BIOS、NVRAM或PROM。固件能够读写PCI控制器中的寄存器，这提供了对配置任务的支持。&lt;br/&gt;
系统引导时，Linux内核在每个PCI外设上执行配置任务，当驱动程序访问设备时，外设的内存和寄存器都已经被映射到CPU的地址空间。&lt;/p&gt;

&lt;p&gt;外设在内核中对应pci_dev结构，驱动在内核中对应pci_driver结构。&lt;br/&gt;
驱动是通过内核模块的方式，在系统启动时加载的。举个栗子，Intel e1000网卡驱动的e1000_main.c中，模块初始化函数是e1000_init_module，它调用pci_register_driver(&amp;amp;e1000_driver)将驱动注册到内核某处，以便同一管理吧。e1000_driver是pci_driver实例，其中函数指针probe被定义为e1000_probe，它调用pci_enable_device()激活e1000网卡。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;网卡类属于PCI设备，因此可以应用前面描述的知识。以Intel Gigabit Ethernet driver(drivers/net/igb)为例，来看网卡上电到工作的过程(&lt;em&gt;参考了“&lt;a href=&quot;http://beyond-syntax.com/blog/2011/03/diving-into-linux-networking-i/&quot;&gt;Diving into the Linux Networking Stack&lt;/a&gt;”&lt;/em&gt;)。&lt;br/&gt;
1、系统启动，发现网卡，初始化pci_dev数据结构。这个数据结构包含多个收包(rx)队列，每个队列之间是独立的，因此可以被多核CPU并行处理。&lt;br/&gt;
2、igb模块被加载，igb_driver结构已经设置好了针对igb网卡的probe、suspend、resume等函数，模块初始化函数将igb driver注册到系统中。&lt;br/&gt;
3、但PCI bus准备好之后，igb网卡已经准备好开始工作，事先注册的igb_probe()被调用，启动igb网卡。&lt;br/&gt;
3.1、igb_probe()做的工作：在PCI bus上启用网卡，设置了I/O memory，设置了设备相关的回调函数(如open、close)，调用igb_sw_init设置一些软件状态并且准备interrupt system，配置了一些硬件细节，确保设备处于一个已知的合法的状态。&lt;br/&gt;
3.2、上述每一步都很重要，却并不特别，其他PCI设备也是这么初始化的。&lt;br/&gt;
3.3、igb网卡真正开始工作，实在igb_open调用之后。&lt;br/&gt;
4、启用igb网卡之后，调用igb_open()。在这里才开始做网卡的实事。&lt;br/&gt;
4.1、分配发包、收包需要的所有资源。&lt;br/&gt;
调用igb_setup_all_tx_resources分配transmit resources。&lt;br/&gt;
调用igb_setup_all_rx_resources分配receive resources。&lt;br/&gt;
现代网卡都支持多队列(rx_rings)，负载可被多核摊分处理，因此分配rx resources时，是对每个队列进行资源分配。&lt;br/&gt;
这里的resource具体指代igb_buffer结构，它是联系igb网卡硬件相关的descriptor ring和软件相关socket buffer的纽带。&lt;br/&gt;
&lt;img src=&quot;/images/igbcard_skb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在上图中，网卡维护一个descriptor ring，ring中每个条目指向主存的一块区域，这块区域就是socket buffer，网络数据包就是写在这块区域中。ring中的每个条目还包含包的元信息，或网卡状态。&lt;br/&gt;
上图右侧，内核维护一个socket buffer pool。不难想象，使用pool的目的是加速。&lt;br/&gt;
网卡和内核唯一的通信方式是中断，当网卡收到一个数据包时，它通过中断告知内核，由内核做包处理。&lt;/p&gt;

&lt;p&gt;igb_alloc_rx_buffers_adv做socket buffer的分配，并关联hardware descriptor。&lt;br/&gt;
socket buffer是通过 &lt;strong&gt;DMA&lt;/strong&gt; 在网卡(hardware)和内核(software)之间建立映射的，因此数据包在network stack之间穿梭时，不需要内存拷贝。&lt;br/&gt;
4.2、设置interrupt handler，但收到包时，内核才知道如何处理。&lt;br/&gt;
需要设置两个中断函数：硬件中断函数和软件中断函数。&lt;br/&gt;
硬件中断：igb_open-&gt;igb_request_irq。现代网卡支持多接收队列，因此网卡应该支持多个硬件中断，以区分是哪个接收队列收到数据了。&lt;br/&gt;
硬件中断的设计目标是快速，一旦完成便触发相关的软件中断，软件中断在一个更加安全的上下文环境中执行，并且不阻止其他中断。所以igb_request_irq会使用netif_napi_add注册一个softIRQ。&lt;br/&gt;
5、网卡可以工作了。&lt;br/&gt;
收包过程：&lt;br/&gt;
当一个网络包到达网卡时，网卡找到下一个可用的hardware descriptor，将网络包写到descriptor指向的socket buffer。&lt;br/&gt;
当然，如果所有descriptor都已经被占用了，网卡就丢弃这个包，并告警overrun。&lt;br/&gt;
当这个网络包被全部接收完成时，网卡触发中断信号，内核开始执行注册好的中断程序。之后便会经历network stack。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;在继续收包流程之前，先来看一些相关的数据结构：sk_buff、route table。&lt;br/&gt;
&lt;em&gt;下面的内容参考了&lt;a href=&quot;http://www.haifux.org/&quot;&gt;haifux&lt;/a&gt;的“&lt;a href=&quot;http://www.haifux.org/lectures/172/&quot;&gt;Linux Kernel Networking Overview&lt;/a&gt;”，此文结尾还给出了很多资料链接。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sk_buff&lt;/strong&gt;&lt;br/&gt;
前面说到，接收的数据包是写到sk_buff结构中的，可知sk_buff表示了网络包的数据和各种header。&lt;br/&gt;
sk_buff变量在内核代码中一般命名为skb，它有3个成员属性：transport_header(第4层transport layer)、network_header(第3层network layer)、mac_header(第2层link layer)。无需解释便可知其大致意图。&lt;br/&gt;
skb的另一个属性_skb_dst，实际上是指向dst_entry结构的指针，dst_entry包含当前skb的路由信息，路由信息和routing subsystem强相关。dst有两个重要函数指针，&lt;em&gt;input和&lt;/em&gt;output，指明skb代表的网络包的去向：在network stack中传递、转发给网络其他节点或丢弃。&lt;br/&gt;
skb.tstamp表示接收包时的时间戳。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;net_device&lt;/strong&gt;&lt;br/&gt;
表示一个网卡(nic，network interface card)。网卡一般是PCI类型的，也有USB类型的，可见net_device和前面提到的pci_dev会是强相关的。&lt;br/&gt;
net_device包含网卡硬件相关的重要属性：mtu(maximum transmission unit，设备能搞定的frame最大size，每个协议有其mtu，Ethernet默认的是1500)，dev_addr(mac地址)，硬件发包函数(2.6.32代码中没有hard_start_xmit指针，却有类似的函数)。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;routing subsystem&lt;/strong&gt;&lt;br/&gt;
路由系统，顾名思义，它记录了一个网络包该发到哪里去。&lt;br/&gt;
有两种记录数据结构：routing table和routing cache，实际上只有routing table，因为routing cache顾名思义是用来加速的。&lt;br/&gt;
routing table的数据结构是fib_table，fib是forwarding information base的缩写。routing cache的数据结构是rtable。&lt;br/&gt;
系统中可以有多个routing table，但只有一个routing cache——这也好理解，就是这么实现的。&lt;code&gt;route -C&lt;/code&gt;可以看routing cache的内容。&lt;br/&gt;
routing cache是通过hash实现的，不过内核还提供了另一种cache查询方式：fib_trie，看起来是利用trie数据结构加快查询，不过需要打开内核的CONFIG_IP_FIB_TRIE选项。这个选项默认是关闭的，大概是对于一般机器来说，路由信息不会太多，hash就能够搞定，还轮不到使用trie吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/route_lookup.png&quot; alt=&quot;&quot; /&gt;&lt;br/&gt;
路由查询使用的算法是LPM(longest prefix match)，举个栗子，设路由系统有两个条目，192.168.20.16/28和192.168.0.0/16，处理地址192.168.20.19时，match这两个条目，但选取最合适的192.168.20.16/28，它的子网掩码最长。&lt;/p&gt;

&lt;p&gt;路由有两种方式：destination-address based decisions、policy routing。&lt;br/&gt;
第一种方式好理解，便是你指定发到哪个地址，我就发到哪个地址。&lt;br/&gt;
policy routing，便是根据一定的rule，去决议该把包发往何处。&lt;code&gt;ip rule list&lt;/code&gt;可看系统中所有的rule。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;继续收包。OSI的七层结构图。&lt;br/&gt;
&lt;img src=&quot;/images/osi.png&quot; alt=&quot;&quot; /&gt;&lt;br/&gt;
前面说到，网卡中断，往skb中写数据。下一步是指针会移动到IP header，准备进入ip层。——net/ethernet/eth.c&lt;br/&gt;
ip层收包函数是ip_rcv。这一层会通过routing subsystem决定包的去往：local delivery、forwarding或dropped。&lt;br/&gt;
local delivery会将包往network stack的上层发，forwarding会将IP header中的ttl减一。&lt;/p&gt;

&lt;p&gt;一份网络文档“&lt;a href=&quot;http://www.cs.unh.edu/cnrg/people/gherrin/linux-net.html&quot;&gt;Linux IP Networking&lt;/a&gt;”，也讨论了network stack、socket方面的内容，摘引其中两份简图：&lt;br/&gt;
&lt;img src=&quot;/images/r_rx.png&quot; alt=&quot;&quot; /&gt;&lt;br/&gt;
&lt;img src=&quot;/images/s_tx.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;不讲细节的话，收一个网络包，从底到上大概就是这个流程。&lt;br/&gt;
先不继续往上，而是来从上往下来看看，便是我们熟知的socket编程了。&lt;br/&gt;
&lt;img src=&quot;/images/socket_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;socket的实现细节，和上面说的sk_buff等有什么关系呢？&lt;br/&gt;
有两本书很详细地讲了socket编程各个函数的内核实现细节：《追踪Linux TCP/IP运行》、《TCP/IP Architecture Design and Implementation in Linux》。这两本书实际上在带着你看代码，其中第一本的内核代码更新。&lt;/p&gt;

&lt;p&gt;socket在内核对应一个文件，socket结构(一般简写为sock)，sock结构(一般简写为sk)。其中sock结构包含很多信息，可以认为它和上面描述的sk_buff那一套建立了联系。&lt;br/&gt;
socket()函数的作用就是初始化这三个东西。至此，可以不负责任地说：listen()、accept()、connect()不过是做类似的事情而已，更新sock等结构，更新TCP状态，通过网卡发包和收包。&lt;br/&gt;
需要特别指出四点，从中可窥一斑：&lt;br/&gt;
1、系统中能创建多少TCP socket，是有上限的，由一个变量指示。&lt;br/&gt;
2、服务端会创建client_sock之类的结构，表示和其建立连接的客户端。&lt;br/&gt;
3、服务端socket有一些队列，如SYN队列、req队列之类。&lt;br/&gt;
4、一切皆文件，socket也不例外，它和VFS是这么建立关联的：&lt;br/&gt;
&lt;img src=&quot;/images/socket_vfs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;TCP在建立连接有著名的“三步握手协议”，在关闭连接时有半关闭问题。&lt;br/&gt;
&lt;img src=&quot;/images/tcp_flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>了解gcov</title>
   <link href="http://blog.leezhong.com/programming/2012/09/03/meet-gcov.html"/>
   <updated>2012-09-03T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/09/03/meet-gcov</id>
   <content type="html">&lt;p&gt;看到网友Lenky的博文“&lt;a href=&quot;http://lenky.info/2012/08/24/gcov%E5%88%9D%E8%AF%95%E7%94%A8/&quot;&gt;gcov初试用&lt;/a&gt;”，产生兴趣，于是继续了解。gcov可以用在Linux内核中，这是最吸引我的一点。&lt;/p&gt;

&lt;p&gt;有两个问题：&lt;br/&gt;
1、gcov的实现原理。&lt;br/&gt;
2、gcov如何工作在Linux内核中。&lt;/p&gt;

&lt;p&gt;gcov还有对应的GUI工具。&lt;/p&gt;

&lt;h3&gt;gcov示例&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;man gcov&lt;/code&gt;。&lt;br/&gt;
示例代码：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;体验步骤：&lt;br/&gt;
1、编译：gcc -fprofile-arcs -ftest-coverage tmp.c&lt;br/&gt;
2、发现生成额外文件：tmp.gcno&lt;br/&gt;
3、执行：./a.out&lt;br/&gt;
4、发现又生成额外文件：tmp.gcda&lt;br/&gt;
5、执行gcov tmp.c，发现生成额外文件tmp.c.gcov&lt;br/&gt;
6、cat tmp.c.gcov，内容如下，“#”表示该行没有执行到。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;gcov原理&lt;/h3&gt;

&lt;p&gt;根据&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov-Intro.html#Gcov-Intro&quot;&gt;gcov官方文档&lt;/a&gt;，gcov只能处理GCC(GNU Compiler Collection)编译的代码。而且gcov是以代码行为处理单位的，所以使用gcov前，最好抑制gcc做代码优化，写代码时别乱并行。&lt;/p&gt;

&lt;p&gt;用户态程序使用gcov的原理：使用编译选项“-fprofile-arcs、-ftest-coverage”，告诉编译器在目标文件中插入额外的代码。执行程序时，收集counter数据，并和源代码关联，生成最终结果。(&lt;a href=&quot;http://lwn.net/2002/0214/a/gcov.php3&quot;&gt;ref&lt;/a&gt;)&lt;/p&gt;

&lt;h3&gt;Linux内核使用gcov&lt;/h3&gt;

&lt;p&gt;内核和用户态程序完全不同，内核不是以一个程序的方式存在的，因此gcov的处理方式也必然不同，暂且不去细究。&lt;/p&gt;

&lt;p&gt;内核gcov的结果是随时间增长的，因为内核一直在运行，比如jbd journal.c，diff结果明显看出计数增加。&lt;br/&gt;
而对于还没有用到的功能，gcov的结果为空，比如jbd recovery.c。&lt;/p&gt;

&lt;p&gt;使用前需配置内核选项，2.6.31之后的内核启用GCOV支持即可，详看这两份文档：&lt;br/&gt;
1、&lt;a href=&quot;http://ltp.sourceforge.net/coverage/gcov.php&quot;&gt;gcov-kernel - a gcov infrastructure for the Linux kernel&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://lenky.info/2012/08/24/%E8%AF%95%E7%94%A8%E5%86%85%E6%A0%B8gcov/&quot;&gt;试用内核gcov&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>理解JBD</title>
   <link href="http://blog.leezhong.com/linux/2012/09/01/jbd-jbd2.html"/>
   <updated>2012-09-01T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/linux/2012/09/01/jbd-jbd2</id>
   <content type="html">&lt;p&gt;日志（Journal）不是一个陌生的事物，ext3和ext2的主要区别便是ext3引入了日志。ext2没有日志，遇到突然断电之类的，ext2会发生不能启动、某些文件混乱等异常。ext3是有日志的，断电后，可以根据日志恢复，仍旧可用且处于一致状态。&lt;/p&gt;

&lt;p&gt;ext3使用的日志功能是由jbd提供的。根据&lt;a href=&quot;http://en.wikipedia.org/wiki/Journaling_block_device#Overview&quot;&gt;wiki&lt;/a&gt;，使用jbd的文件系统并不多：ext3(jbd)，ocfs2(jbd-&gt;jbd2)，ext4(jbd2)。为什么这么少的文件系统使用jbd，不得而知，大概是jbd出生太晚，其他文件系统已经“积重难返”吧。&lt;/p&gt;

&lt;p&gt;在继续之前需指出，日志只保证一致性，不保证绝无数据丢失。面对同样的硬件和掉电这样的场景，我们没法通过增加软件逻辑去确保万无一失。不过如果有这样的硬件：有备用电源，掉电后立即启用备用电源，使得掉电时的数据仍旧有效，那么或许就不需要日志了。&lt;/p&gt;

&lt;p&gt;jbd必须要在磁盘上记录信息，所以ext3的磁盘格式中有一个区域，比如100M大小，专门为日志而留。这个日志区域是定量的，需可重用。因此jbd的工作有：在内存中管理日志、提交日志到磁盘。磁盘上日志空间是有特定格式的，有意思的是日志空间有其superblock，所以可以说是一个小型文件系统。&lt;/p&gt;

&lt;h3&gt;原子操作和事务&lt;/h3&gt;

&lt;p&gt;jbd使用了两个重要的逻辑抽象：原子操作(handle)和事务(transaction)。handle归属于一个transaction，内存中transaction可以有多个，分为三种：1）已经commit到磁盘，正在执行checkpoint操作的；2）正在将数据提交到日志的；3）正在运行的。正在运行的transaction最多只能有一个（这好理解，因为没必要多个），由它管理随后发生的原子操作。&lt;/p&gt;

&lt;p&gt;原子操作很好理解，一件事情要么发生，要么没有发生，不能有中间状态。&lt;br/&gt;
不过这里的原子操作，不是硬件支持的“天生”原子操作，而是由软件逻辑(如加锁)保证的。因此可以调整粒度，比如你可以把写1M作为一个原子操作，也可以把写100M作为一个原子操作。&lt;br/&gt;
如何控制原子操作的粒度才合适？如果FS块大小为1KB，如果把写1M作为原子操作，则其中包括为文件分配1024个数据块，分配若干个索引块，涉及很多块位图操作。整个过程复杂，时间很长，中间出问题的机会很多，因此并不适合作为一个原子操作。&lt;br/&gt;
而为文件分配一个数据块，就适合作为一个原子操作。分配一个数据块，可能需要修改一个inode块、一个磁盘块位图、最多三个间接索引块、block group块、超级块，一共最多7个块。把它作为原子操作，使其要么成功，要么失败，绝不会有中间状态，还是方便控制的。&lt;/p&gt;

&lt;p&gt;另外把一个原子操作作为事务处理，效率较低。ext3将多个原子操作组合成一个事务，提高日志读写效率。&lt;/p&gt;

&lt;h3&gt;ext3的三种日志模式&lt;/h3&gt;

&lt;p&gt;ext3支持三种日志模式：&lt;br/&gt;
1、journal。文件系统所有数据库和元数据块的改变都记入日志。这是最安全，也是最慢的ext3日志模式。&lt;br/&gt;
2、ordered。只对文件系统元数据块的改变才记入日志，这样可以保证文件系统的一致性，但是不能保证文件内容的一致性。不过ext3确保在元数据块写入日志之前，先写入数据库，这样减少文件内数据损坏的机率。这是默认的ext3日志模式。&lt;br/&gt;
3、writeback。和ordered类似，只对元数据改变才记入日志，不过不同于ordered，它对数据块不闻不问，即不会去保证先写数据再写日志。这是最快的模式。&lt;/p&gt;

&lt;h3&gt;流程&lt;/h3&gt;

&lt;p&gt;日志操作必须是揉合在文件系统操作之中的，才能记录每一个重要细节。以ext3_mkdir()为例，创建一个目录时：&lt;br/&gt;
1、ext3_journal_start()，做文件系统操作之前，先获得handle。transaction处理被封装在其中了&lt;br/&gt;
2、创建和初始化inode&lt;br/&gt;
3、ext3_journal_get_write_access()&lt;br/&gt;
4、更新元数据&lt;br/&gt;
5、ext3_journal_dirty_metadata()&lt;br/&gt;
6、标记inode为脏&lt;br/&gt;
7、ext3_journal_stop()&lt;br/&gt;
8、mkdir完成&lt;/p&gt;

&lt;p&gt;上面的API都是在jbd API上的浅层封装。&lt;/p&gt;

&lt;p&gt;因此，为一个现成的、没有日志功能的文件系统增加日志功能，实现会很麻烦，会深入原来流程的每个细节。&lt;/p&gt;

&lt;h3&gt;transaction lifecycle&lt;/h3&gt;

&lt;p&gt;in progress: 正在运行的transaction，管理随后的原子操作，在内存中更新。&lt;br/&gt;
completed：比如transaction用满了，不能再处理后续原子操作，后续原子操作需要新的transaction。这时transaction位于内存中。&lt;br/&gt;
commited：transaction写到磁盘日志空间，标志为commited。如果文件系统异常，可用来replay。&lt;br/&gt;
checkpointed：数据更新被真正地持久化到磁盘上，此时，内存和磁盘日志空间中对应的transaction都是没用的了，需要被删除，以被重复利用。&lt;/p&gt;

&lt;p&gt;commit transaction是交给kjournald内核线程做的，两个条件触发commit：定时(5s)和“定量”(比如transaction用满了)。&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;至此，已大致能疏通胸中块垒。&lt;/p&gt;

&lt;p&gt;所以jbd的工作可以总结为：在执行文件系统操作时，即时记录日志；日志主要通过事务和原子操作这两大概念管理；日志先由kjournald commit到磁盘，等到文件系统数据也被持久化之后，再删除对应的日志；如果文件系统异常，mount时检查日志，存在的transaction记录没有持久化的数据，据此恢复。&lt;/p&gt;

&lt;p&gt;当然，对于jbd，我还有很多问题不明白：&lt;br/&gt;
1、细节。我没有去整理详细的过程。&lt;br/&gt;
2、日志commit之前，会不会数据先写回？这类问题和文件系统、Linux内核缓冲区等基础知识相关，我理解不深，不明白。&lt;br/&gt;
3、jbd2和jbd的区别。&lt;/p&gt;

&lt;p&gt;本文参考：Linux源码、&lt;a href=&quot;http://cgi.cse.unsw.edu.au/~cs3231/12s1/lectures/lect11x6.pdf&quot;&gt;大学讲义&lt;/a&gt;、&lt;a href=&quot;http://blogimg.chinaunix.net/blog/upfile2/101018213331.pdf&quot;&gt;网友(pwp.cublog.cn)的JBD源码分析&lt;/a&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>了解分布式系统</title>
   <link href="http://blog.leezhong.com/programming/2012/08/23/distributed-system-basis.html"/>
   <updated>2012-08-23T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/08/23/distributed-system-basis</id>
   <content type="html">&lt;p&gt;&lt;em&gt;OT-1：好久没有写博文，因为：(1)现在下笔要比以前&lt;del&gt;谨慎&lt;/del&gt;(本文又冲动了)。(2)更多考虑该去做什么，而不是拿起一个东西就学。另一方面，自己要看的东西大多都看过，已经有初步的理解，剩下的便是实战历练。(3)在针对性地复习算法，从常用到不常用。这是爱好，但不是短期内大成的，重体悟而非记录，所以也没写下来。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OT-2：也在纠结工作的事情，不知道未来做什么，没有考虑清楚。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;以下正文。&lt;/p&gt;

&lt;p&gt;云计算、大数据...一年一热词，所谓新瓶装旧酒，核心还是分布式技术而已。&lt;br/&gt;
说起分布式，难逃网络通信。这就是一个很复杂的问题，就我的经历来说，没有好的协议和设计，写出来的代码所爆发的问题是爆炸式的。&lt;br/&gt;
相比其他，分布式中的网络问题更为重要。这么多年来，想必已有经验教训、模型可供参考。该了解这些知识，不能自己瞎撞。&lt;/p&gt;

&lt;p&gt;有一个&quot;&lt;a href=&quot;http://dancres.org/reading_list.html&quot;&gt;A Distributed Systems Reading List&lt;/a&gt;&quot;，列出了很多分布式方面的论文书籍。本文是阅读记录。&lt;/p&gt;

&lt;p&gt;结构上遵循原文。&lt;/p&gt;

&lt;h3&gt;Thought Provokers&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.411&quot;&gt;Harvest, Yield and Scalable Tolerant Systems&lt;/a&gt; - Real world applications of CAP from Brewer et al&lt;/p&gt;

&lt;p&gt;这是99年，斯坦福和伯克利的人发的文章，没什么猛料。它提出两个方向：&lt;br/&gt;
1）妥协(trade-off)。没细看，难逃“为达到A效果，牺牲一定的B效果”。&lt;br/&gt;
2）细分系统，错误隔离。这一条实际上不堪大用，虽然我很认同。它的思路是：把大系统合理地细分，从而把各种错误限制在小模块中，从而提升整体的容错度。这个思路听起来很美，做出来的系统很“干净”，却很需要经验吧。&lt;/p&gt;

&lt;p&gt;这是我看的第一篇，它“提出”貌似江湖闻名的“CAP principle”，C-consistency（一致性）、A-high availability（高可用）、P-partition-resilience（容错？集群挂掉一两个节点，不碍事）。&lt;/p&gt;

&lt;p&gt;Strong CAP principle：三者取其二，不能俱全。&lt;br/&gt;
这是例证的，所以挺“神棍的”。&lt;br/&gt;
1）CA without P：有分布式语义的数据库。&lt;br/&gt;
2）CP without A：&lt;br/&gt;
3）AP without C：HTTP web caching。&lt;/p&gt;

&lt;p&gt;另外有一个“weak CAP principle”，没有继续了解。&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.mvdirona.com/jrh/talksAndPapers/JamesRH_Lisa.pdf&quot;&gt;On Designing and Deploying Internet Scale Services&lt;/a&gt; - &lt;a href=&quot;http://www.mvdirona.com/jrh/work/&quot;&gt;James Hamilton&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;James Hamilton，看起来眼熟啊(&lt;em&gt; &lt;/em&gt;!!!)，Amazon Web Services Team的，这篇感觉是大招。看后发现，整篇是经验总结，由MSN、Windows Live的分布式网络服务开发中总结而来。比如江湖闻名的“Design for failure”。&lt;/p&gt;

&lt;p&gt;也就不逐条列出了，直接看paper吧，&lt;a href=&quot;http://blog.csdn.net/blade2001/article/details/6067652&quot;&gt;有人&lt;/a&gt;也整理了一个列表。总的来说，没有“革命性”的猛料...&lt;br/&gt;
列出一些重要的：&lt;br/&gt;
1）design for failure&lt;br/&gt;
2）redundancy and fault recovery&lt;br/&gt;
3）commodity hardware slice，这条大概指“一群破机器，能打败大型机”，也就是hadoop那种模式。&lt;br/&gt;
4）single-version software，集群中跑同样的代码，不要去傻呵呵地支持多版本。&lt;br/&gt;
5）Zero trust of underlying components，不要相信底层，不要完全依赖底层来保证稳定。&lt;br/&gt;
6）Do not build the same functionality in multiple components、Keep things simple and robust、keep deployment simple，这几条是类似的，保证简单可依赖（所以，百度今年的口号很靠谱！），这样看起来容易，改起来也容易。同时这些也是“ship offen”的保障，有了这些，才有号称的“敏捷开发”，想很久、设计很久、码很久、调试很久=必死。&lt;br/&gt;
7）Understand the network design、Analyze throughput and latency，理解网络，胸中要有各个部分的平均性能数据。这个网上有个图，把一次读cache、发一条网络消息的大概时间列出来了，就是这个道理。&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://www.addsimplicity.com/adding_simplicity_an_engi/2007/02/latency_exists_.html&quot;&gt;Latency Exists, Cope!&lt;/a&gt; - Commentary on coping with latency and it's architectural impacts&lt;/p&gt;

&lt;p&gt;这不是一篇论文，这是一篇博文，它很给力！&lt;/p&gt;

&lt;p&gt;关于延时，我是有体会的，在我看来，网络通信、进程调度的不确定性，带来服务响应时间的不可控，尤其网络高压、或者系统问题导致进程hang住时。&lt;/p&gt;

&lt;p&gt;这就纠结了，如何处理这种情况才合适，应该还是要“特定情况特定分析”。上面这篇文章给出了一些指导，很受教：&lt;br/&gt;
1）解耦！还是这个，高耦合就挂了！&lt;br/&gt;
2）异步通信，并且考虑带expectation。这条给力！经历过的人都懂的，虽然一般的分布式服务都会考虑到，但就看考虑得好不好，实现得好不好了。&lt;br/&gt;
3）不要依赖一个数据中心。这点就暂不考虑了。&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://www.igvita.com/2012/07/19/latency-the-new-web-performance-bottleneck/&quot;&gt;Latency - the new web performance bottleneck&lt;/a&gt; - not at all new (see Patterson), but noteworthy&lt;/p&gt;

&lt;p&gt;这是一篇博文，重点在web时延，不是我关心的，略过。不过这篇博文的呈现方式很有特色。&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;http://www.addsimplicity.com/adding_simplicity_an_engi/2006/12/the_perils_of_g.html&quot;&gt;The Perils of Good Abstractions&lt;/a&gt; - Building the perfect API/interface is difficult&lt;/p&gt;

&lt;p&gt;这篇博文的作者和(3)的作者是同一人，内容核心还是那两个字：解耦。&lt;/p&gt;

&lt;p&gt;6、&lt;a href=&quot;http://www.addsimplicity.com/adding_simplicity_an_engi/2007/05/chaotic_perspec.html&quot;&gt;Chaotic Perspectives&lt;/a&gt; - Large scale systems are everything developers dislike - unpredictable, unordered and parallel&lt;/p&gt;

&lt;p&gt;作者还是写(3、5)的大叔，文章大致看了看，只是讨论，没有结论性的东西，略过。&lt;/p&gt;

&lt;p&gt;7、&lt;a href=&quot;http://poorbuthappy.com/ease/archives/2007/04/29/3616/the-top-10-presentation-on-scaling-websites-twitter-flickr-bloglines-vox-and-more&quot;&gt;Website Architecture&lt;/a&gt; - A collection of scalable architecture papers from various of the large websites&lt;/p&gt;

&lt;p&gt;这是一个合集，包括讲述twitter、Flickr、LiveJournal扩展的slides，搞网站的童鞋不容错过，我就先路过了。&lt;/p&gt;

&lt;p&gt;8、&lt;a href=&quot;http://www.cidrdb.org/cidr2005/papers/P12.pdf&quot;&gt;Data on the Outside versus Data on the Inside&lt;/a&gt; - Pat Helland&lt;/p&gt;

&lt;p&gt;微软发的SOA方面的论文。&lt;/p&gt;

&lt;p&gt;9、&lt;a href=&quot;http://blogs.msdn.com/b/pathelland/archive/2007/05/15/memories-guesses-and-apologies.aspx&quot;&gt;Memories, Guesses and Apologies&lt;/a&gt; - Pat Helland&lt;/p&gt;

&lt;p&gt;这是一篇博文，题目中“Guesses、Apologies”的含义没去细究。作者的思路，还是那句话，避免“大而全”的东西。看作者的总结：&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Consider the cost/benefit of building big-ass and expensive machines!  Careful design of a collection of replicas may fill the business need at a better value!&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;10、&lt;a href=&quot;http://blogs.msdn.com/pathelland/archive/2007/05/20/soa-and-newton-s-universe.aspx&quot;&gt;SOA and Newton's Universe&lt;/a&gt; - Pat Helland&lt;/p&gt;

&lt;p&gt;这篇应该是(10)的延伸。&lt;/p&gt;

&lt;p&gt;11、&lt;a href=&quot;http://arxiv.org/abs/0909.1788&quot;&gt;Building on Quicksand&lt;/a&gt; - Pat Helland&lt;/p&gt;

&lt;p&gt;这是09年的论文。我们不得不“在浮沙筑高台”。此时怎么办？异步机制。异步带来时延不可控，怎么办？...凉拌...&lt;/p&gt;

&lt;p&gt;到目前为止，对于分布式中异步方式带来的时延和错误，我认为没有根本的解决方法，需要根据项目特点细致地对待。&lt;/p&gt;

&lt;p&gt;12、&lt;a href=&quot;http://www.artima.com/weblogs/viewpost.jsp?thread=4247&quot;&gt;Why Distributed Computing?&lt;/a&gt; - &lt;a href=&quot;http://www.eecs.harvard.edu/~waldo/&quot;&gt;Jim Waldo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是03年的博文。从简历看，Jim Waldo是一个达人，经历的知名公司有HP、Sun、VMware，现在在哈佛任教。从他应可深挖资料。&lt;/p&gt;

&lt;p&gt;这个短文辩论了即使“有更快的CPU，更快的网络，更大的存储容量，所有请求都可以由一台机器搞定”，分布式计算还是必须的，因为“机器的进化速度&amp;lt;计算要求的增长”。作者调侃：如果有这么一台超强的机器，不需要搞分布式，那么程序员就轻松了，不用再考虑“partial failure”了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13、&lt;a href=&quot;http://labs.oracle.com/techrep/1994/abstract-29.html&quot;&gt;A Note on Distributed Computing&lt;/a&gt; - Waldo, Wollrath et al&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;94年的一篇老论文，来自Jim Waldo和他在Sun的同仁们，他们当时好像在做NFS，NFS我不熟悉，但却在快20年后的今天，我仍看到有人在使用它。Sun还真是一个nb的公司，技艺精湛，可惜技术非钱。&lt;/p&gt;

&lt;p&gt;对我，目前为止，这篇论文最给力！它对分布式系统的核心问题做了定义，比我已了解的要多、要深入，虽然它只是指出了问题，没有给出解决方法。&lt;br/&gt;
完美的解决方法，可能根本不存在。&lt;/p&gt;

&lt;p&gt;看起来，他们一开始的思路是：提供API，隔离本地和分布式操作的区别。这样的API是诱人的，程序员会很喜欢。但实际经验告诉他们，这种抽象必然导致失败，你必须正视本地程序和分布式程序的区别，既不能使用纯分布式的API去抽象本地操作，也不能使用本地形式的API去抽象分布式。&lt;/p&gt;

&lt;p&gt;所以Unified Objects是行不通的：&lt;br/&gt;
“The Vision of Unified Objects”&lt;br/&gt;
在分布式环境下，使用object-oriented思路，抽象和隔离底层分布式细节。这样做貌似可以带来好处：1）归约到程序员熟悉的object-oriented设计。2）failure、performance问题限制在模块实现中，不在初始设计中。3）完美的抽象，便利的扩展，适合不同的分布式环境。&lt;br/&gt;
然而，这是自欺欺人的，通过摆弄新概念去规避核心问题（分布式的时延、容错、服务质量保障），必然是不靠谱的。&lt;/p&gt;

&lt;p&gt;下面列出论文对分布式计算核心问题的阐述。&lt;/p&gt;

&lt;p&gt;分布式计算的核心问题有四：&lt;br/&gt;
1）latency&lt;br/&gt;
2）memory access&lt;br/&gt;
3）partial failure&lt;br/&gt;
4）concurrency&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;partial failure is a central reality of distributed computing.&lt;br/&gt;
A central problem in distributed computing is insuring that the state of the whole system is consistent after such a failure.&lt;br/&gt;
Partial failure requires that programs deal with indeterminacy.&lt;br/&gt;
Being robust in the face of partial failure requires some expression at the interface level.&lt;br/&gt;
Different implementations of an interface may provide different levels of reliability, scalability, or performance.&lt;br/&gt;
Robustness is not simply a function of the implementations of the interfaces that make up the system.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;论文还说到，NFS有两种mount方式：soft mount、hard mount。soft mount把network、server failure暴露给客户端程序，由客户端控制。hard mount则是由服务端执行挂载动作，期间客户端是hang住的，直到服务端操作完成。hard mount看起来很霸道，用户体验也不好，但却是用的最多的方式。&lt;/p&gt;

&lt;p&gt;“hard mount用得多”告诉我们，在分布式计算中，能少一事绝不多一事，约定好过程序处理。&lt;/p&gt;

&lt;h3&gt;Amazon&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;Somewhat about the technology but more interesting is the culture and organization they've created to work with it.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;1、&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1142065&quot;&gt;A Conversation with Werner Vogels&lt;/a&gt; - Coverage of Amazon's transition to a service-based architecture&lt;br/&gt;
2、&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1388773&quot;&gt;Discipline and Focus&lt;/a&gt; - Additional coverage of Amazon's transition to a service-based architecture&lt;br/&gt;
3、&lt;a href=&quot;http://www.itconversations.com/shows/detail1634.html&quot;&gt;Vogels on Scalability&lt;/a&gt;&lt;br/&gt;
4、&lt;a href=&quot;http://searchwebservices.techtarget.com/originalContent/0,289142,sid26_gci1195702,00.html&quot;&gt;SOA creates order out of chaos @ Amazon&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Google&lt;/h3&gt;

&lt;p&gt;分布式系统中的“rocket science”。&lt;/p&gt;

&lt;p&gt;1、&lt;a href=&quot;http://labs.google.com/papers/mapreduce.html&quot;&gt;MapReduce&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://labs.google.com/papers/chubby.html&quot;&gt;Chubby Lock Manager&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://labs.google.com/papers/gfs.html&quot;&gt;Google File System&lt;/a&gt;&lt;br/&gt;
4、&lt;a href=&quot;http://labs.google.com/papers/bigtable.html&quot;&gt;BigTable&lt;/a&gt;&lt;br/&gt;
5、&lt;a href=&quot;http://www.usenix.org/event/worlds06/tech/prelim_papers/perl/perl.pdf&quot;&gt;Data Management for Internet-Scale Single-Sign-On&lt;/a&gt;&lt;br/&gt;
6、&lt;a href=&quot;http://www.google.com/research/pubs/pub36632.html&quot;&gt;Dremel: Interactive Analysis of Web-Scale Datasets&lt;/a&gt;&lt;br/&gt;
7、&lt;a href=&quot;http://www.google.com/research/pubs/pub36726.html&quot;&gt;Large-scale Incremental Processing Using Distributed Transactions and Notifications&lt;/a&gt;&lt;br/&gt;
8、&lt;a href=&quot;http://www.cidrdb.org/cidr2011/Papers/CIDR11_Paper32.pdf&quot;&gt;Megastore: Providing Scalable, Highly Available Storage for Interactive Services&lt;/a&gt; - Smart design for low latency Paxos implementation across datacentres.&lt;/p&gt;

&lt;h3&gt;Consistency Models&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;Key to building systems that suit their environments is finding the right tradeoff between consistency and availability.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;1、&lt;a href=&quot;http://lpd.epfl.ch/sgilbert/pubs/BrewersConjecture-SigAct.pdf&quot;&gt;CAP Conjecture&lt;/a&gt; - Consistency, Availability, Parition Tolerance cannot all be satisfied at once&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Two years later, in 2002, Seth Gilbert and Nancy Lynch of MIT, formally proved Brewer to be correct and thus Brewer's Theorem was born.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.cs.utexas.edu/users/princem/papers/cac-tr.pdf&quot;&gt;Consistency, Availability, and Convergence&lt;/a&gt; - Proves the upper bound for consistency possible in a typical system&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;=2010的一篇新论文。看不懂！&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;3、&lt;a href=&quot;http://www.julianbrowne.com/article/viewer/brewers-cap-theorem&quot;&gt;Brewer's CAP Theorem&lt;/a&gt; - Julian Browne&lt;/p&gt;

&lt;p&gt;一篇博文，通俗地描述了CAP。&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://www.infoq.com/news/2008/01/consistency-vs-availability&quot;&gt;Consistency and Availability&lt;/a&gt; - Vogels&lt;br/&gt;
5、&lt;a href=&quot;http://www.allthingsdistributed.com/2007/12/eventually_consistent.html&quot;&gt;Eventual Consistency&lt;/a&gt; - Vogels&lt;br/&gt;
6、&lt;a href=&quot;http://www.addsimplicity.com/adding_simplicity_an_engi/2006/12/avoiding_two_ph.html&quot;&gt;Avoiding Two-Phase Commit&lt;/a&gt; - Two phase commit avoidance approaches&lt;br/&gt;
7、&lt;a href=&quot;http://www.addsimplicity.com/adding_simplicity_an_engi/2006/12/2pc_or_not_2pc_.html&quot;&gt;2PC or not 2PC, Wherefore Art Thou XA?&lt;/a&gt; - Two phase commit isn't a silver bullet&lt;br/&gt;
8、&lt;a href=&quot;https://database.cs.wisc.edu/cidr/cidr2007/papers/cidr07p15.pdf&quot;&gt;Life Beyond Distributed Transactions&lt;/a&gt; - Helland&lt;br/&gt;
9、&lt;a href=&quot;http://www.enterpriseintegrationpatterns.com/docs/IEEE_Software_Design_2PC.pdf&quot;&gt;Starbucks doesn't do two phase commit&lt;/a&gt; - Asynchronous mechanisms at work&lt;/p&gt;

&lt;p&gt;10、&lt;a href=&quot;http://codahale.com/you-cant-sacrifice-partition-tolerance/&quot;&gt;You Can't Sacrifice Partition Tolerance&lt;/a&gt; - Additional CAP commentary&lt;/p&gt;

&lt;p&gt;这篇文章很有意思，他很有观点：不能放弃Partition Tolerance，如果放弃了，意味着你的分布式程序必须运行在一个绝对稳定的网络中，&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;For a distributed (i.e., multi-node) system to not require partition-tolerance it would have to run on a network which is &lt;strong&gt;guaranteed&lt;/strong&gt; to never drop messages (or even deliver them late) and whose nodes are guaranteed to never die.&lt;/p&gt;

&lt;p&gt;You and I do not work with these types of systems because &lt;strong&gt;they don’t exist&lt;/strong&gt;.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;所以，要么选择consistency，而放弃一定的availablity，或者相反，但P不能放弃。&lt;/p&gt;

&lt;p&gt;11、&lt;a href=&quot;http://www.ece.cmu.edu/~ece845/docs/optimistic-data-rep.pdf&quot;&gt;Optimistic Replication&lt;/a&gt; - Relaxed consistency approaches for data replication&lt;/p&gt;

&lt;h3&gt;Theory&lt;/h3&gt;

&lt;blockquote&gt;&lt;p&gt;Papers that describe various important elements of distributed systems design.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;1、&lt;a href=&quot;http://research.microsoft.com/research/pubs/view.aspx?tr_id=655&quot;&gt;Distributed Computing Economics&lt;/a&gt; - Jim Gray&lt;/p&gt;

&lt;p&gt;计算是要花钱的，这篇来自美刀公司的Technical Report为你算算这笔帐。&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://research.microsoft.com/pubs/68636/ms_tr_99_100_rules_of_thumb_in_data_engineering.pdf&quot;&gt;Rules of Thumb in Data Engineering&lt;/a&gt; - Jim Gray and Prashant Shenoy&lt;/p&gt;

&lt;p&gt;同样来自美刀的2000年的technical report，告诉你数据会很多，会很重要...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、&lt;a href=&quot;http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing&quot;&gt;Fallacies of Distributed Computing&lt;/a&gt; - Peter Deutsch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Sun司大拿们总结的，分布式计算中的谬误：&lt;br/&gt;
1）网络是可靠的。。。&lt;br/&gt;
2）latency is zero。。。&lt;br/&gt;
3）带宽是无限的。。。&lt;br/&gt;
4）网络是安全的。。。&lt;br/&gt;
5）拓扑结构是不会变的。。。&lt;br/&gt;
6）只有一个管理员。。。&lt;br/&gt;
7）transport cost is zero...&lt;br/&gt;
8）网络是对等的（homogeneous：均匀的，同种的）。。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、&lt;a href=&quot;http://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf&quot;&gt;Impossibility of distributed consensus with one faulty process&lt;/a&gt; - also known as FLP&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看标题，distributed consensus，分布式如何达成共识，是基本问题之一。却是1985年的论文，ACM的。我不由想起Zookeeper和Google Chubby。&lt;/p&gt;

&lt;p&gt;这篇文章主要给出一个论点：没有靠谱的一致性协议。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;THEOREM 1. No consensus protocol is totally correct in spite of one fault.&lt;br/&gt;
THEOREM 2. There is a partially correct consensus protocol in which all nonfaulty processes always reach a decision, provided no processes die during its execution and a strict majority of the processes are alive initially.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;结论：fault-tolerant cooperative computing cannot be solved in a totally asynchronous model of computation. 但这并不是说，分布式共识就一定搞不定，而是需要更精确的模型，比如对计算环境更多的假设、更多的预设限制（给出，我就是只能保证，在这些情况下不出大问题，如果发生其他例外，听天由命吧。。。）。&lt;/p&gt;

&lt;p&gt;目前对此文的理解就是这样。&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;http://www.ecommons.cornell.edu/bitstream/1813/7192/1/95-1535.pdf&quot;&gt;Unreliable Failure Detectors for Reliable Distributed Systems&lt;/a&gt;. A method for handling the challenges of FLP&lt;/p&gt;

&lt;p&gt;91年ACM上的老文，给出(4)提出问题的一个解决方案。很长，51页，共提出45+条定理和推论，尼玛，定理生产机器啊，不知道是不是我朝的刷榜风格...直接看不下去啊有木有...&lt;/p&gt;

&lt;p&gt;6、&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/time-clocks.pdf&quot;&gt;Lamport Clocks&lt;/a&gt; - How do you establish a global view of time when each computer's clock is independent&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Leslie_Lamport&quot;&gt;Leslie Lamport&lt;/a&gt;，便是写出Paxos算法的那个牛人。Paxos算法面世颇有一番“传奇”，这个相信很多人都懂的，于是，这篇78年的爷爷论文，估计不会啰嗦。&lt;/p&gt;

&lt;p&gt;不过，本文要解决的问题是，分布式环境下，给event排时序。算法貌似好理解，但我想不到应用场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/byz.pdf&quot;&gt;The Byzantine Generals Problem&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;拜占庭将军问题，直接略过论文，看其他资料：&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98&quot;&gt;wiki&lt;/a&gt;、&lt;a href=&quot;http://zhiqiang.org/blog/science/computer-science/tcs-byzantine-failure-the-byzantine-generals-problem.html&quot;&gt;阅微堂&lt;/a&gt;。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;拜占庭将军问题 (Byzantine Generals Problem)，是由莱斯利兰伯特提出的点对点通信中的基本问题。 在分布式计算上，不同的计算机透过讯息交换，尝试达成共识；但有时候，系统上协调计算机 (Coordinator / Commander) 或成员计算机 (Member / Lieutanent) 可能因系统错误并交换错的讯息，导致影响最终的系统一致性。拜占庭将军问题就根据错误计算机的数量，寻找可能的解决办法 (但无法找到一个绝对的答案，只可以用来验证一个机制的有效程度)。&lt;/p&gt;

&lt;p&gt;军队与军队之间分隔很远，传讯息的信差可能在途中路上阵亡，或因军队距离，不能在得到消息后即时回复，发送方也无法确认消息确实丢失的情形，导致不可能达到一致性。&lt;strong&gt;在分布式计算上，试图在异步系统和不可靠的通道上达到一致性是不可能的&lt;/strong&gt;。因此对一致性的研究一般假设信道是可靠的，或不存在异步系统上而行。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;8、&lt;a href=&quot;http://citeseer.nj.nec.com/ladin90lazy.html&quot;&gt;Lazy Replication: Exploiting the Semantics of Distributed Services&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;9、&lt;a href=&quot;http://static.usenix.org/event/hotdep10/tech/full_papers/Kapritsos.pdf&quot;&gt;Scalable Agreement - Towards Ordering as a Service&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Paxos算法一般用来解决分布式共识问题，但是这些协议是不可扩展的，因而可能最终成为性能瓶颈。这篇论文提出一个新的可扩展的分布式共识方案。&gt;=2010年，米国某大学+yahoo出品。&lt;/p&gt;

&lt;h3&gt;Languages and Tools&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://docmanual.com/Read/_vp.bWFuLmx1cGF3b3JsZC5jb20-_vp..sl_content.sl_develop.sl_p37-svensson.pdf&quot;&gt;Programming Distributed Erlang Applications: Pitfalls and Recipes&lt;/a&gt; - Building reliable distributed applications isn't as simple as merely choosing Erlang and OTP.&lt;/p&gt;

&lt;h3&gt;Infrastructure&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://queue.acm.org/detail.cfm?id=1773943&quot;&gt;Principles of Robust Timing over the Internet&lt;/a&gt; - Managing clocks is essential for even basics such as debugging&lt;/p&gt;

&lt;h3&gt;Storage&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://www.akamai.com/dl/technical_publications/ConsistenHashingandRandomTreesDistributedCachingprotocolsforrelievingHotSpotsontheworldwideweb.pdf&quot;&gt;Consistent Hashing and Random Trees&lt;/a&gt;，distributed caching protocols for relieving Hot Spots on the world wide web&lt;br/&gt;
2、&lt;a href=&quot;http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html&quot;&gt;Amazon's Dynamo Storage Service&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Paxos Consensus&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf&quot;&gt;The Part-Time Parliament&lt;/a&gt; - Leslie Lamport&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、&lt;a href=&quot;http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf&quot;&gt;Paxos Made Simple&lt;/a&gt; - Leslie Lamport&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Paxos解决的问题，不同于拜占庭将军问题，虽然可能有一条消息被传递多次，但绝不会出现错误的消息。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://libpaxos.sourceforge.net/&quot;&gt;libpaxos&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://labs.google.com/papers/paxos_made_live.html&quot;&gt;Paxos Made Live - An Engineering Perspective&lt;/a&gt; - Chandra et al&lt;br/&gt;
4、&lt;a href=&quot;http://groups.csail.mit.edu/tds/paxos.html&quot;&gt;Revisiting the Paxos Algorithm&lt;/a&gt; - Lynch et al&lt;br/&gt;
5、&lt;a href=&quot;http://research.microsoft.com/lampson/58-Consensus/Acrobat.pdf&quot;&gt;How to build a highly available system with consensus&lt;/a&gt; - Butler Lampson&lt;br/&gt;
6、&lt;a href=&quot;http://research.microsoft.com/en-us/um/people/lamport/pubs/reconfiguration-tutorial.pdf&quot;&gt;Reconfiguring a State Machine&lt;/a&gt; - Lamport et al - changing cluster membership&lt;br/&gt;
7、&lt;a href=&quot;http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.20.4762&quot;&gt;Implementing Fault-Tolerant Services Using the State Machine Approach: a Tutorial&lt;/a&gt; - Fred Schneider&lt;/p&gt;

&lt;h3&gt;Other Consensus Papers&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://www.usenix.org/event/osdi08/tech/full_papers/mao/mao_html/&quot;&gt;Mencius: Building Efficient Replicated State Machines for WANs&lt;/a&gt; - consensus algorithm for wide-area network&lt;/p&gt;

&lt;h3&gt;Gossip Protocols(Epidemic Behaviours)&lt;/h3&gt;

&lt;p&gt;一类模拟社会中流言传播方式的协议？&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;...The concept of gossip communication can be illustrated by the analogy of office workers spreading rumors...[&lt;a href=&quot;http://en.wikipedia.org/wiki/Gossip_protocol&quot;&gt;Gossip protocol&lt;/a&gt;]&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;1、&lt;a href=&quot;http://infoscience.epfl.ch/record/109302?ln=en&quot;&gt;How robust are gossip-based communication protocols?&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://www.cs.cornell.edu/home/rvr/papers/astrolabe.pdf&quot;&gt;Astrolabe: A Robust and Scalable Technology For Distributed Systems Monitoring, Management, and Data Mining&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://www.allthingsdistributed.com/historical/archives/000456.html&quot;&gt;Epidemic Computing at Cornell&lt;/a&gt;&lt;br/&gt;
4、&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.4000&quot;&gt;Fighting Fire With Fire: Using Randomized Gossip To Combat Stochastic Scalability Limits&lt;/a&gt;&lt;br/&gt;
5、&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.7959&quot;&gt;Bi-Modal Multicast&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;Experience at MySpace&lt;/h3&gt;

&lt;h3&gt;eBay&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>粗读muduo.net</title>
   <link href="http://blog.leezhong.com/programming/2012/08/02/muduo-net.html"/>
   <updated>2012-08-02T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/08/02/muduo-net</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://code.google.com/p/muduo/&quot;&gt;muduo.net&lt;/a&gt;指陈硕写的C++开源网络库，学习它的目的是：&lt;br/&gt;
1、了解网络编程。&lt;br/&gt;
2、学习C++实践。&lt;/p&gt;

&lt;p&gt;muduo.net是极佳的网络编程学习资料，陈硕对此写了一系列的文章，讨论了网络编程的模式和一些细节。比如：&lt;br/&gt;
1、&lt;a href=&quot;http://files.cppblog.com/Solstice/multithreaded_server.pdf&quot;&gt;多线程服务器的常用编程模型&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://blog.csdn.net/solstice/article/details/5848547&quot;&gt;发布一个基于Reactor模式的C++网络库&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://blog.csdn.net/solstice/article/details/6527585&quot;&gt;一谈网络编程学习经验(06-08更新)&lt;/a&gt;&lt;br/&gt;
4、&lt;a href=&quot;http://blog.csdn.net/solstice/article/details/5364096&quot;&gt;学之者生，用之者死——ACE历史与简评&lt;/a&gt;&lt;br/&gt;
5、&lt;a href=&quot;https://github.com/downloads/chenshuo/documents/MuduoManual.pdf&quot;&gt;muduo manual&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;据此深入下去，一定能入网络编程的大门。但我日常不接触网络编程，不能碰触到实际问题，不能形成有效经验，如果就此猛扎下去，担心事倍功半。因此，本文不会深入细节，只列记muduo.net的要点。&lt;/p&gt;

&lt;p&gt;对于目的之二，陈硕说道“muduo.net使用的是object-based C++，而非object-oriented C++”，从源码也可以看出，muduo.net只有5000行左右的代码，没有乱七八糟的继承，&lt;strong&gt;大量的回调机制&lt;/strong&gt;都使用boost::function+boost::bind，代码简洁同时表达力强！&lt;/p&gt;

&lt;p&gt;下面说明muduo.net的设计，穿插说明一些网络编程要点和C++实践技巧。muduo.net蕴涵的网络编程精义，非现在力所能及。&lt;/p&gt;

&lt;h3&gt;从EchoServer说起&lt;/h3&gt;

&lt;p&gt;muduo.net示例之一便是EchoServer，main函数很简单：&lt;br/&gt;
1、创建EventLoop loop。EventLoop是muduo.net的灵魂，是陈硕选用的一种网络编程模式：reactor in threads。这种方案的特点是one loop per thread，有一个main reactor负责accept连接，然后把连接挂在某个sub reactor中（以round-robin的方式选择sub reactor），这样该连接的所有操作都在那个sub reactor所处的线程中完成。多个连接可能被分配到多个线程中，以充分利用CPU。使用固定大小的reactor pool，大小一般根据CPU核数确定。&lt;em&gt;更多相关陈述，参考MuduoManual 1.6.2 “常见的比方网络服务程序设计方案”。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;2、创建EchoServer server，以EventLoop指针和InetAddress实例作为参数，InetAddress很好理解，只是ip的封装。&lt;br/&gt;
3、调用server.start()，进而调用TcpServer.start()，开始侦听连接请求。&lt;br/&gt;
4、调用loop.loop()，处理每一个连接的消息。&lt;/p&gt;

&lt;p&gt;这些简单步骤的示例代码：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;上面的步骤后面有三个细节值得关注：&lt;br/&gt;
1、muduo.net的抽象方式。&lt;br/&gt;
2、EventLoop的工作方式。&lt;br/&gt;
3、socket发送和接收buffer&lt;/p&gt;

&lt;h4&gt;muduo.net的抽象方式&lt;/h4&gt;

&lt;p&gt;1、EchoServer包含一个TcpServer。&lt;/p&gt;

&lt;p&gt;2.1、TcpServer包含一个Acceptor，用来监听客户端连接请求。&lt;br/&gt;
2.1.1、Acceptor包含一个Socket，它只是socket的简单封装。&lt;br/&gt;
2.1.2、Acceptor包含一个Channel，Channel表示一个连接通道，封装底层socket的通信，和下面的TcpConnection对比便明白。&lt;/p&gt;

&lt;p&gt;2.2、TcpServer包含一个EventLoopThreadPool，这就是前文提到的reactor pool，不展开说，暂只考虑一个EventLoop的处理方式。&lt;/p&gt;

&lt;p&gt;2.3、TcpServer还包含一个TcpConnection集合，用来表示所有的Tcp连接。TcpConnection跟Acceptor类似，不过语义不同而已。&lt;br/&gt;
2.3.1、TcpConnection包含一个Socket，不用解释。&lt;br/&gt;
2.3.2、TcpConnection包含一个Channel，表示通信通道，和前面一样。&lt;/p&gt;

&lt;p&gt;所以，新建一个EchoServer时，新建一个TcpServer，创建Acceptor监听连接请求，每来一个请求，将请求加到TcpConnection集合中，并分配给某个sub reactor（这里只考虑一个sub reactor，不考虑reacotr pool）。之后每个连接的通信就交给sub reactor（EventLoop）做。&lt;/p&gt;

&lt;p&gt;整个抽象过程中，用到一堆一堆的回调函数，前面已经说过，都是用boost::function+boost::bind来实现的，很方便。&lt;/p&gt;

&lt;h4&gt;EventLoop的工作方式&lt;/h4&gt;

&lt;p&gt;假设现在EventLoop管理100个连接，socket上什么时候有新数据来是不确定的，要检查和处理每个连接的数据读写，最土的方法就是轮询。但一般的做法是用select/poll/epoll，这三个机制要实现同一目的，作用是快速检查一堆设备（这里是socket）是否有数据待处理。&lt;/p&gt;

&lt;p&gt;所以每个EventLoop包含一个Poller，Poller的子类有PollPoller、EPollPoller、DefaultPoller，最终分别用poll和epoll系统调用，select好像没用到，估计是太土了。&lt;/p&gt;

&lt;p&gt;所以EventLoop的主体loop()函数大致如下：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h4&gt;socket发送和接收buffer&lt;/h4&gt;

&lt;p&gt;在reactor模式下，使用发送和接收buffer，是必要的。比如在write()时，你想发送100k，但是OS只接受了80k，你肯定不想原地等待发剩下的20k，你不知道要等多久，程序应该快速交出控制权，返回event loop，处理其他TcpConnection。所以看起来要维护发送和接收buffer。更详细的论述看MuduoManual的2.4节“Buffer类的设计与使用”，不细说。&lt;/p&gt;

&lt;h3&gt;网络编程本质论&lt;/h3&gt;

&lt;p&gt;在“&lt;a href=&quot;http://blog.csdn.net/Solstice/article/details/6171831&quot;&gt;Muduo 网络编程示例之零：前言&lt;/a&gt;”，陈硕指出“TCP网络编程最本质的是处理三个半事件”：&lt;br/&gt;
1、连接的建立，包括服务端接受(accept)新连接和客户端成功发起(connect)连接。&lt;br/&gt;
2、连接的断开，包括主动断开(close或shutdown)和被动断开(read 返回 0)。&lt;br/&gt;
3、消息到达，文件描述符可读。这是最为重要的一个事件，对它的处理方式决定了网络编程的风格（阻塞还是非阻塞，如何处理分包，应用层的缓冲如何设计等等）。&lt;br/&gt;
4、消息发送完毕，这算半个。对于低流量的服务，可以不必关心这个事件；另外，这里“发送完毕”是指将数据写入操作系统的缓冲区，将由TCP协议栈负责数据的发送与重传，不代表对方已经收到数据。&lt;/p&gt;

&lt;p&gt;这其中有很多难点，也有很多细节需要注意，比方说：&lt;br/&gt;
1、如果要主动关闭连接，如何保证对方已经收到全部数据？如果应用层有缓冲（这在非阻塞网络编程中是必须的，见下文），那么如何保证先发送完缓冲区中的数据，然后再断开连接。直接调用close(2)恐怕是不行的。&lt;br/&gt;
2、如果主动发起连接，但是对方主动拒绝，如何定期(带back-off)重试？&lt;br/&gt;
3、非阻塞网络编程该用边沿触发(edge trigger)还是电平触发(level trigger)？如果是电平触发，那么什么时候关注EPOLLOUT事件？会不会造成busy-loop？如果是边沿触发，如何防止漏读造成的饥饿？epoll一定比poll快吗？&lt;br/&gt;
4、在非阻塞网络编程中，为什么要使用应用层缓冲区？假如一次读到的数据不够一个完整的数据包，那么这些已经读到的数据是不是应该先暂存在某个地方，等剩余的数据收到之后再一并处理？见lighttpd关于 /r/n/r/n 分包的 bug。假如数据是一个字节一个字节地到达，间隔10ms，每个字节触发一次文件描述符可读(readable)事件，程序是否还能正常工作？lighttpd 在这个问题上出过安全漏洞。&lt;br/&gt;
5、在非阻塞网络编程中，如何设计并使用缓冲区？一方面我们希望减少系统调用，一次读的数据越多越划算，那么似乎应该准备一个大的缓冲区。另一方面，我们系统减少内存占用。如果有10k个连接，每个连接一建立就分配64k的读缓冲的话，将占用640M内存，而大多数时候这些缓冲区的使用率很低。muduo用readv 结合栈上空间巧妙地解决了这个问题。&lt;br/&gt;
6、如果使用发送缓冲区，万一接收方处理缓慢，数据会不会一直堆积在发送方，造成内存暴涨？如何做应用层的流量控制？&lt;br/&gt;
7、如何设计并实现定时器？并使之与网络IO共用一个线程，以避免锁。&lt;/p&gt;

&lt;p&gt;这就是我立即“收手”的原因，没有实战机会，看太深未免纸上谈兵。&lt;/p&gt;

&lt;h3&gt;其他&lt;/h3&gt;

&lt;p&gt;比如&lt;a href=&quot;http://www.cnblogs.com/TianFang/archive/2008/09/15/1291050.html&quot;&gt;boost::scoped_ptr&lt;/a&gt;、&lt;a href=&quot;http://www.cnblogs.com/TianFang/archive/2008/09/20/1294590.html&quot;&gt;boost::weak_ptr&lt;/a&gt;的使用，在muduo代码中可以领略到。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>理解C++异常处理</title>
   <link href="http://blog.leezhong.com/programming/2012/07/31/cpp-exception-handle.html"/>
   <updated>2012-07-31T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/31/cpp-exception-handle</id>
   <content type="html">&lt;p&gt;在“&lt;a href=&quot;http://xanpeng.github.com/programming/2012/07/12/exception-handle.html&quot;&gt;如何实现异常处理&lt;/a&gt;”中，我希望了解一种编程语言是如何实现异常(exception)机制的，但最终没有达到预期，现在仍然纠结。但今天想到：我应是将异常处理想得太复杂，在我的旧印象里，如果使用了异常处理，程序将永远稳健地执行，即使遇到除0。这是痴心妄想，除0是需要做特殊处理的，否则terminate。&lt;/p&gt;

&lt;p&gt;说到底，我并没有认清C++异常的定义。大多书籍没有专门讲述（除非被我错过），在stackoverflow上看到相关讨论，总结于此。&lt;/p&gt;

&lt;p&gt;C++眼里的异常，是software-detected errors，比如文件不存在这样的“异常”场景。程序员完全可以不用异常，而使用error code，就像在C语言中处理类似“异常”场景一样————所以，异常只是一种编程手段而已。&lt;br/&gt;
除0，程序在cli输出“Floating point exception”，这里虽有“exception”字样，但FPE&lt;strong&gt;不是&lt;/strong&gt;C++异常处理机制中的“Exception”，是&lt;strong&gt;不可捕获&lt;/strong&gt;的。FPE是一种典型的hardware exception，发生FPE时操作系统的典型做法是向进程发送&lt;strong&gt;SIGFPE&lt;/strong&gt;信号，如果没有特别处理此信号，进程的默认行为一般是terminate。&lt;/p&gt;

&lt;p&gt;因此，异常可划分为“软件异常”和“system-level exception”，而大家一般讨论的是第一种，本文则专门讨论C++异常处理，不考虑FPE这样的system-level exception。&lt;/p&gt;

&lt;p&gt;下列文章针对FPE和Exception的区别：&lt;br/&gt;
1、&lt;a href=&quot;http://stackoverflow.com/questions/9366215/why-does-gcc-report-a-floating-point-exception-when-i-execute-1-0&quot;&gt;Why does GCC report a Floating Point Exception when I execute 1/0?&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://stackoverflow.com/questions/2219244/dealing-with-floating-point-exceptions&quot;&gt;Dealing with Floating Point exceptions&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://stackoverflow.com/questions/4747934/c-catch-a-divide-by-zero-error&quot;&gt;C++ : Catch a divide by zero error&lt;/a&gt;&lt;br/&gt;
4、&lt;a href=&quot;http://stackoverflow.com/questions/618215/how-do-i-catch-system-level-exceptions-in-linux-c&quot;&gt;How do I catch system-level exceptions in Linux C++?&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;产生本文的原因之一，便是解决了FPE和Exception的纠结，此时发现“&lt;a href=&quot;http://xanpeng.github.com/programming/2012/07/12/exception-handle.html&quot;&gt;如何实现异常处理&lt;/a&gt;”中的描述是不恰当的，我会在原文首部添加警告。&lt;br/&gt;
产生本文的原因之二，便是同事问我，如果在构造函数中发生异常，会怎么办？对于C++异常处理（再次表明：不考虑FPE等），我阅读颇多，不过脑中一团浆糊。于是趁此机会做一整理和了解，并告诉他best practice!&lt;/p&gt;

&lt;p&gt;将讨论下面的话题，所有讨论都限定于C++的异常处理（Exception Handling）：&lt;br/&gt;
1、什么是Exception？&lt;br/&gt;
2、编译器如何实现Exception Handling？（原来有此执念，是误以为要handle FPE，现已澄清，其实已不太有此念了）&lt;br/&gt;
3、用还是不用Exception？&lt;br/&gt;
4、如何用Exception？&lt;br/&gt;
5、Exception-safe&lt;/p&gt;

&lt;h3&gt;什么是Exception&lt;/h3&gt;

&lt;p&gt;C++的异常处理不包含FPE等system-level exception。所以，这里说的Exception只是一种类似于error code的处理方式。&lt;/p&gt;

&lt;p&gt;C++标准异常的基类是class Exception，&lt;a href=&quot;http://www.cplusplus.com/reference/std/stdexcept/&quot;&gt;stdexcept&lt;/a&gt;中定义了一些常用的异常，分为两类：logic_error（domain_error，invalid_argument，length_error，out_of_range）和runtime_error（range_error，overflow_error，underflow_error），new会抛出bad_alloc异常。&lt;/p&gt;

&lt;h3&gt;编译器如何实现Exception Handling&lt;/h3&gt;

&lt;p&gt;原来误认为exception handling也要处理FPE的时候，觉得很是神奇，不知编译器是如何和内核协调处理FPE的。但现在既已明白，不管FPE，那么编译器实现exception handling的方式也可以想见，不过是在用户态做策略而已。&lt;/p&gt;

&lt;p&gt;略加搜索，找到一些G++实现异常处理的资料，且列于此：&lt;br/&gt;
1、&lt;a href=&quot;http://www.math.utah.edu/docs/info/gxxint_1.html&quot;&gt;Internal Architecture of the Compiler&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://stackoverflow.com/questions/490773/how-is-the-c-exception-handling-runtime-implemented&quot;&gt;How is the C++ exception handling runtime implemented?&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://www.codeproject.com/Articles/2126/How-a-C-compiler-implements-exception-handling&quot;&gt;How a C++ compiler implements exception handling&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在自无必要去了解这些实现策略，但关乎exception使用的细节，自然是要知道的，下面列出c++2003std “Exception handling”中的有趣内容：&lt;br/&gt;
1、不能用goto，switch跳入try block或handler，这样打乱了try-catch的逻辑。&lt;br/&gt;
2、抛出异常时，会有一个object被传递给handler，object类型用来确定调用哪一个handler。&lt;br/&gt;
3、throw表达式创建的对象称为exception object，the memory is allocated in an unspecified way，其生命周期由handler确定，只要有handler在处理，exception object所占内存就仍保持。&lt;br/&gt;
4、...&lt;/p&gt;

&lt;h3&gt;用不用Exception Handling&lt;/h3&gt;

&lt;p&gt;经过查询资料，我的结论是：要用Exception Handling。&lt;/p&gt;

&lt;p&gt;不用Exception的理由：&lt;br/&gt;
1、有性能损耗吧？&lt;br/&gt;
2、Google就不用Exception（&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Exceptions&quot;&gt;Google cppguide#Exception&lt;/a&gt;）。&lt;/p&gt;

&lt;h4&gt;使用Exception会带来性能损耗吗？&lt;/h4&gt;

&lt;p&gt;如果没有抛出异常，则没有性能损耗；如果抛出异常，则有部分性能损耗，不过此时如果使用error code，也仍然是有损耗的。&lt;br/&gt;
——参考“&lt;a href=&quot;http://stackoverflow.com/questions/307610/how-do-exceptions-work-behind-the-scenes-in-c&quot;&gt;How do exceptions work(behind the scenes) in c++&lt;/a&gt;”。&lt;/p&gt;

&lt;p&gt;而且，现在的我绝对不到考虑这么一点性能损耗的时候，首先现代编译器的性能值得相信，其次采用更好的算法才是提升性能的正途！&lt;/p&gt;

&lt;h4&gt;Google为什么不用Exception&lt;/h4&gt;

&lt;p&gt;Google在他的cppguide上列出了使用exception的优劣，指出缺点是产生更大的binary file，（可能）要更多的compile time，不确切的程序执行路径，增加维护和调试难度，以及不当使用带来的风险（这个要用，自然就要用好了，汗！）。实际上，可以看出，Google最终决定不用exception，多是因为历史原因，他有很多历史的C++项目没有使用Exception。&lt;/p&gt;

&lt;p&gt;另外“&lt;a href=&quot;http://stackoverflow.com/questions/3490106/we-do-not-use-c-exceptions-whats-the-alternative-let-it-crash&quot;&gt;We do not use C++ exceptions — What's the alternative? Let it crash?&lt;/a&gt;”和“&lt;a href=&quot;http://programmers.stackexchange.com/questions/113479/are-there-any-real-world-cases-for-c-without-exceptions&quot;&gt;Are there any real-world cases for C++ without exceptions?&lt;/a&gt;”都讨论了是否使用Exception。&lt;/p&gt;

&lt;p&gt;延伸这个讨论内容，就到了剪裁使用C++，孟岩在“&lt;a href=&quot;http://blog.csdn.net/myan/article/details/1920&quot;&gt;编程语言的层次观点——兼谈C++的剪裁方案&lt;/a&gt;”就讨论了这个话题。C++语言特性很多，很多我还不能深刻理解，于是剪裁话题暂列于此，不作展开。&lt;/p&gt;

&lt;h3&gt;如何使用Exception&lt;/h3&gt;

&lt;p&gt;考虑三个问题：&lt;br/&gt;
1、普通情况下，使用异常的best practice。&lt;br/&gt;
2、构造函数中是否能抛出异常，怎么处理？&lt;br/&gt;
3、析构函数中是否能抛出异常，怎么处理？&lt;/p&gt;

&lt;p&gt;讨论这三个问题的资料：&lt;a href=&quot;http://en.wikibooks.org/wiki/C%2B%2B_Programming/Exception_Handling&quot;&gt;wikibook#C++_Exception_Handling&lt;/a&gt;，《More Effective C++》的条款10“在构造函数中防止资源泄漏”、条款11“禁止异常信息传递到析构函数外”。&lt;/p&gt;

&lt;h4&gt;非ctor/dtor的Exception Handling&lt;/h4&gt;

&lt;p&gt;如何抛出异常？自然是通过throw表达式。前文c++2003std部分提到，throw创建一个临时的exception object，在handler生命周期内都有效。而且，标准并不规定在内存的何处（堆、栈、全局区、其他？）创建exception object(原文是allocated in an unspecified way)，于是也不知道exception object是如何被销毁的。&lt;br/&gt;
所以，抛出异常的正确写法是：thrown by value，caught by (usually const) reference。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;异常在没被handle之前，会循着调用路径往回传递，过程中发生“&lt;a href=&quot;http://en.wikibooks.org/wiki/C%2B%2B_Programming/Exception_Handling#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt;”，栈会被清除，栈内局部变量生命触底，dtor被调用，局部变量内存被回收，不会发生内存泄漏，但在堆上分配的内存，除非特别处理（使用smart pointer），否则仍然会泄漏。看示例代码：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h4&gt;ctor中的Exception Handling&lt;/h4&gt;

&lt;p&gt;ctor出错时，抛出此异常是最好的做法（但也可以把可能出错的代码放入init()，保证ctor不会异常）。&lt;a href=&quot;http://www.parashift.com/c++-faq-lite/ctors-can-throw.html&quot;&gt;How can I handle a constructor that fails?&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;Throw an exception.&lt;br/&gt;
Constructors don't have a return type, so it's not possible to use return codes. The best way to signal constructor failure is therefore to throw an exception. If you don't have the option of using exceptions, the &quot;least bad&quot; work-around is to put the object into a &quot;zombie&quot; state by setting an internal status bit so the object acts sort of like it's dead even though it is technically still alive.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;如果在ctor中抛出异常，会不会发生内存泄漏？&lt;br/&gt;
ctor异常时，对象未完整构建，dtor不会被调用，但异常发生前的对象会被合理析构。这其实和上面f1()-&gt;f2-&gt;f3()的例子是同一问题，stack unwind保证dtor的调用。同样，在堆上分配的内存需要特别处理。&lt;br/&gt;
ctor抛出异常前，可能创建了基本类型(int,long等)的变量、指针变量、用户自定义类型变量，C++都“平等地”看待这些不同的类型——即C++不会像Java那样自作主张把所有class变量都放在堆上。&lt;br/&gt;
这里面指针变量比较特殊，ctor异常后，指针变量本身遵循同样的规则，而被正确清理，但是它指向的对象不能被自动清理，从而发生内存泄漏。同样地，可以使用smart pointer解决这类问题（exception-safe部分会细说）。&lt;br/&gt;
看ctor异常示例代码：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h4&gt;dtor中的Exception Handling&lt;/h4&gt;

&lt;p&gt;dtor不能抛出异常！&lt;br/&gt;
如果dtor抛出异常，程序会立即终止。这是因为，如果在处理其他异常时，在stack unwind过程中执行dtor，dtor又抛出新的异常，此时C++ runtime system如何处理是好？！忽略新异常，不行！忽略旧异常，然后处理新异常，也不行！&lt;br/&gt;
所以，C++语法规定，dtor抛出异常时，程序终止并杀死进程。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;上述内容参考C++ FAQ “&lt;a href=&quot;http://www.parashift.com/c++-faq-lite/dtors-shouldnt-throw.html&quot;&gt;[17.9] How can I handle a destructor that fails?&lt;/a&gt;”。&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;exception-safe&lt;/h3&gt;

&lt;p&gt;如何做异常安全（exception-safe）编程？&lt;em&gt;我在很久以前的“&lt;a href=&quot;http://xanpeng.github.com/programming/2012/02/12/cpp-exception-safe.html&quot;&gt;C++ 异常安全&lt;/a&gt;”中提及此问题，特此说明。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;什么是异常安全？&lt;/p&gt;

&lt;p&gt;暂无时间来解答此问题。回答此问题需要经验积累，我想留待以后。&lt;br/&gt;
不过，异常安全的重要一点是保证没有资源泄漏。防止资源泄漏，一般的做法便是smart pointer。&lt;/p&gt;

&lt;p&gt;列出一些资料：&lt;br/&gt;
1、&lt;a href=&quot;http://www.gotw.ca/gotw/059.htm&quot;&gt;Exception-Safe Class Design, Part 1: Copy Assignment &lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://en.wikibooks.org/wiki/More_C++_Idioms/Copy-and-swap&quot;&gt;More C++ Idioms/Copy-and-swap&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://stackoverflow.com/questions/1853243/c-do-you-really-write-exception-safe-code&quot;&gt;C++: do you (really) write exception safe code?&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;列出我未发布的一篇旧文。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;我们都知道，数据库有事务的概念。据我理解，数据库的“事务性”保证属于同一个transaction的操作要么都成功并进入新的状态，要么transaction失败并保持原有状态，绝对不允许出现的是“中间状态”，即transaction中的某些操作成功，某些操作失败，这是不被允许的情景。&lt;br/&gt;
我们在C++编程中也有同样的考虑：一个函数的执行是成功，还是失败，如果失败，是否会“部分成功”，即是否会产生副作用。本文将考虑这个问题，借用数据库事务的概念，我们称该问题为C++“事务一致性”问题。&lt;br/&gt;
我们希望有一个工具包帮助解决问题，如果根本不存在这样的工具包，我们希望得到一种“指导思想”帮助我们认清并尽量解决C++“事务一致性”的问题。&lt;/p&gt;

&lt;p&gt;实际上我们可以将“事务一致性&quot;问题转化为异常安全性(exception-safe)问题。如果函数执行过程中不会发生任何异常，则函数将执行成功，我们说该函数的“事务”成功完成。&lt;br/&gt;
当异常被抛出时，具有异常安全性的函数需要满足以下两点：&lt;br/&gt;
1、不泄漏任何资源。&lt;br/&gt;
2、不允许数据败坏。&lt;/p&gt;

&lt;p&gt;举例说明，假设有一个绘制菜单背景的类成员函数：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;该代码片段没有做到第1点，因为如果“new Image(imgSrc)”发生异常，unlock将不被执行，使得mutex被永远锁住。&lt;br/&gt;
同样，该代码也没有实现第2点，因为如果“new Image(imgSrc)”发生异常，bgImage指向的是一个被删除的对象，imageChanges也被累加，但实际上新图像并没有安装成功。&lt;/p&gt;

&lt;p&gt;解决异常安全第一点“资源泄漏”问题是很容易的。&lt;br/&gt;
我们要确保任何时候资源总能被释放，因此我们不能依靠手动保证对每一次new都调用相应的delete，即使如此，我们依然不能保证每一个new对应的delete都能得到执行。&lt;br/&gt;
解决该问题的关键是利用C++&lt;strong&gt;析构函数自动调用机制&lt;/strong&gt;。其主要思路是：&lt;br/&gt;
1、获得资源后立刻放进管理对象(managing object)内。&lt;br/&gt;
2、管理对象在离开作用域时自动调用析构函数确保资源被释放。&lt;/p&gt;

&lt;p&gt;我们常用的管理对象有std::auto_ptr和boost::shared_ptr(或std::tr1::shared_ptr)。如对于上文提及例子中的lock(&amp;amp;mutex)，我们可以做如下修改：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;本小节考虑异常安全的第2点“数据败坏”问题。但是解决数据败坏问题远没有解决资源泄漏那么简单。&lt;br/&gt;
我们可以把异常安全分为几个级别：&lt;br/&gt;
1、None。代码不保证异常安全，代码可能有严重的资源泄漏，可能在异常发生时崩溃。&lt;br/&gt;
2、Basic。这是我们代码应该提供的基本保证。当异常发生时，要求没有资源泄漏，所有的对象都是完整的。如类的约束条件依然获得满足，菜单的背景可以是原来的图像，也可以是缺省的图像，但客户无法预期。&lt;br/&gt;
3、Strong。函数流程执行要么全部成功，或者发生异常，当发生异常时，所有的数据必须保持流程执行前的状态。&lt;br/&gt;
4、Nothrow/nofail。函数流程总是会成功执行。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;上面的代码虽能编译执行，但不提供任何异常安全性。即处于None级别。因为如果第3步异常，x 将泄漏。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;上面的代码提供basic级别的异常安全保证，无论何处发生异常，该函数均不会造成资源泄漏。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;面的代码提供strong级别的异常安全保证，即不会发生资源泄漏，同时函数要么成功进入新状态，要么失败保持原有状态。&lt;br/&gt;
从代码可以看出，这里我们使用了一种“copy-and-swap”的策略。如果某处发生异常，t仍然保持原来的状态不变，因为4~7步修改的是t的副本t2，同时我们可以认为第8步swap操作总是能够成功的(nothrow/nofail 级别)。&lt;br/&gt;
从该示例代码也可以看出，我们对t做了备份t2，最终用t2替换t，这涉及两次额外的拷贝操作，如果t数据量很大的话，这些操作带来很多额外的时间。因此，在任意情况下保持strong级别的异常安全性并不一定是实用的，要根据项目实际看是否必要。&lt;br/&gt;
NOTE：我们为什么认为第8步swap总是能成功？我认为原因是：第8步的操作都是最基本的操作，就像整数相加一样。虽然我也认为没有一行命令会永远能够成功执行(比如机器突然断电就有可能让其失败)，但是为了分析方便，我们不考虑这些不常见因素(事实上，这一点或许就是平时最困扰我们的，但我认为我们要知道：我们不可能写出任何内外部因素下都能正确执行的代码)。&lt;/p&gt;

&lt;p&gt;总而言之，就如希望做到bug-free一样，我们是很难写出完全exception-safe的代码，但我们总是根据项目特点综合考虑，写出符合要求的代码。&lt;br/&gt;
可见，我想没有某个万能的工具包能够一劳永逸地解决异常安全性问题，但是本文提出的思路可以帮助我们写出更加exception-safe的代码。&lt;/p&gt;&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>理解muduo.thread</title>
   <link href="http://blog.leezhong.com/programming/2012/07/28/muduo-thread.html"/>
   <updated>2012-07-28T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/28/muduo-thread</id>
   <content type="html">&lt;p&gt;迄今为止，我发布的muduo相关文章有：&lt;br/&gt;
1、&lt;a href=&quot;http://xanpeng.github.com/programming/2012/06/22/muduo-boost.html&quot;&gt;boost in muduo&lt;/a&gt; &lt;br/&gt;
2、&lt;a href=&quot;http://xanpeng.github.com/programming/2012/06/18/muduo-logging.html&quot;&gt;muduo's c++ high-perf logging&lt;/a&gt;&lt;br/&gt;
迄今为止，我发布的pthreads相关文章有：&lt;br/&gt;
1、&lt;a href=&quot;http://xanpeng.github.com/linux/2012/03/28/linux-pthread.html&quot;&gt;Linux pthreads 多线程库&lt;/a&gt;&lt;br/&gt;
2、&lt;a href=&quot;http://xanpeng.github.com/linux/2012/05/15/more-linux-pthreads.html&quot;&gt;more pthreads&lt;/a&gt;&lt;br/&gt;
3、&lt;a href=&quot;http://xanpeng.github.com/linux/2012/06/15/pthreads-api.html&quot;&gt;pthreads--userspace perspective&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;自夸：可以看出认知愈来愈深，文章写作也愈来愈好。现在看来，前文有两大缺点：1、内容不足不深，表述不清。2、自7.9换用新博客模板，旧文布局多有瑕疵。&lt;br/&gt;
这是遗憾，也是必然。&lt;/p&gt;

&lt;p&gt;muduo.thread指代muduo中的C++多线程库，陈硕的“&lt;a href=&quot;http://blog.csdn.net/Solstice/article/details/5829421&quot;&gt;发布一个 Linux 下的 C++ 多线程库&lt;/a&gt;”做出简介。&lt;br/&gt;
库的内容：&lt;br/&gt;
1、整数的原子操作，AtomicInt32、AtomicInt64&lt;br/&gt;
2、线程，Thread&lt;br/&gt;
3、线程池，ThreadPool&lt;br/&gt;
4、互斥量和条件变量，MutexLock、Condition、MutexLockGuard&lt;br/&gt;
5、模仿Java concurrent的BlockingQueue和CountdownLatch&lt;br/&gt;
6、Singleton和ThreadLocal&lt;/p&gt;

&lt;h3&gt;AtomicInt32，AtomicInt64&lt;/h3&gt;

&lt;p&gt;定义于Atomic.h中，分别是模板类AtomicIntegerT的特化，&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;typedef detail::AtomicIntegerT&amp;lt;int32_tAtomicInt32;&lt;br/&gt;
typedef detail::AtomicIntegerT&amp;lt;int64_tAtomicInt64;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;我平时很少接触到使用AtomicInt的需求，不理解其使用场景。其原子性是通过&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html&quot;&gt;gcc atomic-builtin&lt;/a&gt;方法实现的，如：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;Condition、MutexLock和MutexLockGuard&lt;/h3&gt;

&lt;p&gt;muduo用于Linux环境，故而MutexLock、Condition等必然是pthreads的抽象，使之适合C++面向对象语义，使具更优的表达能力。要理解Mutex等，需要理解pthreads，并理解如何抽象才更为合适。&lt;/p&gt;

&lt;h4&gt;mutex&lt;/h4&gt;

&lt;p&gt;pthreads中的mutex：&lt;br/&gt;
1、变量类型pthread_mutex_t。&lt;br/&gt;
2、初始化，有两种方式：静态PTHREAD_MUTEX_INITIALIZER，动态pthread_mutex_init()。&lt;br/&gt;
3、加锁pthread_mutex_lock()，pthread_mutex_trylock()用的较少。&lt;br/&gt;
4、解锁pthread_mutex_unlock()。&lt;br/&gt;
5、销毁pthread_mutex_destroy()。&lt;br/&gt;
6、attr相关操作。&lt;/p&gt;

&lt;p&gt;MutexLock封装pthreads mutex，ctor初始化mutex，dtor销毁mutex，lock()封装pthread_mutex_lock()，unlock则相反。同时，MutexLock还记录mutex的holder。看代码（去除不重要的细节，改变代码排版）：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;MutexLockGuard通过ctor和dtor封装Mutex lock和unlock的调用，避免用户直接调用lock/unlock，预防错误使用。代码很简单：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h4&gt;condition&lt;/h4&gt;

&lt;p&gt;pthreads中条件变量condition的使用是和mutex天生关联的，多个线程访问共享内存，就某些特定条件需要做出协调时，就需要使用condition。如对公共队列queue，producer和consumer都访问它，producer往其中push，consumer从其中pop，则producer应等待queue非满，consumer需等待queue非空。&lt;/p&gt;

&lt;p&gt;对pthreads condition的使用：&lt;br/&gt;
1、变量类型pthread_cond_t。&lt;br/&gt;
2、初始化，PTHREAD_COND_INITIALIZER或pthread_cond_init()。&lt;br/&gt;
3、等待条件满足，pthread_cond_wait(condition, mutex)。这里显示了pthreads中condition和mutex的紧密关联天性，调用前mutex需被加锁，而在wait时，此函数会自动解锁mutex。而当条件满足时——即其他地方调用signal时，此函数会自动加锁mutex，之后程序员需自行负责解锁。&lt;br/&gt;
4、唤醒。有两种方式，pthread_cond_signal()和pthread_cond_broadcast()，后者用于多个线程wait时。&lt;br/&gt;
5、销毁pthread_cond_destroy()。&lt;br/&gt;
6、attr相关操作。&lt;/p&gt;

&lt;p&gt;Condition封装pthreads condition，在ctor/dtor中做pthread_cond_init/destroy，提供wait()/notify()/notifyAll()，分别是对pthreads中对应函数的简单封装。Condition类的一个小细节是定义MutexLock&amp;amp;，而非定义MutexLock，因为后者构造一个新的变量，违背语义。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;Thread&lt;/h3&gt;

&lt;p&gt;pthreads中线程的操作：&lt;br/&gt;
1、线程描述符pthread_t。&lt;br/&gt;
2、创建线程pthread_create()。&lt;br/&gt;
3、终止线程pthread_exit()。&lt;br/&gt;
4、join和detach。&lt;/p&gt;

&lt;p&gt;Thread封装pthreads基本的线程管理，其中的数据成员有：&lt;br/&gt;
1、线程描述符pthread_t&lt;br/&gt;
2、线程pid_t id&lt;br/&gt;
3、线程的工作函数，为函数指针类型，通过boost::function定义&lt;br/&gt;
4、线程名字&lt;br/&gt;
5、标志线程是否启动的bool started&lt;em&gt;&lt;br/&gt;
6、AtomicInt32变量numCreated&lt;/em&gt;，保存创建的线程数目&lt;/p&gt;

&lt;p&gt;线程是何时开始执行的？想起这个问题时，我楞了一下。线程是创建之后就“立即”执行了——“立即”意为你无需再显示调用pthread_start()之类的函数。所以Thread::start()函数仅仅是封装pthread_create()。列出Thread的函数：&lt;br/&gt;
1、Thread::start()，封装pthread_create()&lt;br/&gt;
2、Thread::join()，封装pthread_join()&lt;br/&gt;
3、线程工作函数func&lt;em&gt;由boost::function定义，由用户传入，但func&lt;/em&gt;并不直接传入pthread_create()，而是被startThread做了一层wrap，增加了try-catch保护&lt;/p&gt;

&lt;p&gt;所以，Thread是简单的，其亮点之一是boost::function定义线程工作函数，之二是存储了pid——Thread是如何自省得到pid的了？下一小节说明。&lt;/p&gt;

&lt;h3&gt;namespace CurrentThread&lt;/h3&gt;

&lt;p&gt;CurrentThread是一个namespace，不是一个class。其主要目的是获取当前线程的名字和ID，可以想见是通过系统调用实现的，但非直接调用gettid()，而是调用syscall(SYS_gettid)，这么做应是为避免&lt;a href=&quot;http://xanpeng.github.com/linux/2012/05/19/ps-getpid.html&quot;&gt;glibc cache&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;ThreadPool&lt;/h3&gt;

&lt;p&gt;顾名思义，将线程放在集合中，形成线程池。好处是节省频繁创建销毁现场的开销、控制线程的数量。&lt;br/&gt;
ThreadPool的主要功能：&lt;br/&gt;
1、定义Thread队列，控制线程数目。&lt;br/&gt;
2、定义任务队列deque&lt;Task&gt;，如果用户高频提交任务，线程池处理不过来，这个队列就会很长。&lt;br/&gt;
3、deque&lt;Task&gt;被MutexLock+Condition保护。&lt;/p&gt;

&lt;p&gt;线程终止有&lt;a href=&quot;https://computing.llnl.gov/tutorials/pthreads/#CreatingThreads&quot;&gt;多种方式&lt;/a&gt;，其中之一便是线程顺利完成任务而“自然”退出。于是，这个有一个疑问：ThreadPool的线程必然不能完成一个任务就退出，它们要循环地处理用户提交的Task，对此ThreadPool的实现方法是简单巧妙的：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;然而，ThreadPool又如何正常退出？ThreadPool::stop()通过两个步骤退出：&lt;br/&gt;
1、设置running_=false，使得线程不再从deque&lt;Task&gt;中获取新任务。&lt;br/&gt;
2、等待(join)每一个线程结束。&lt;/p&gt;

&lt;p&gt;但还有一个细节：何时调用ThreadPool::stop()？不考虑时机，随意调用stop()，线程池终止时可能还有Task没有完成。&lt;br/&gt;
ThreadPool并不提供策略处理此场景，而由用户在外层自行处理。ThreadPool_test.cc中采用的方案是CountDownLatch，即往deque&lt;Task&gt; push一个countdown任务，此任务完成之后，调用ThreadPool::stop()。用户只要在countdown之后不再push Task即可，便于控制。——这也说明，目前ThreadPool是按FIFO顺序处理任务的，未作其他策略。&lt;/p&gt;

&lt;p&gt;下面给出代码，先列出用户代码，用户代码揭示ThreadPool的对外接口，是代码分析入口。为了节省篇幅，下面的代码调整了格式，删除了不紧要内容。从中可以看出boost::function+boost::bind用起来是多么简单优美！&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;ThreadLocal，BlockQueue，CountDownLatch&lt;/h3&gt;

&lt;p&gt;线程局部变量，平时几无接触，暂不分析。BlockQueue、CountDownLatch也只是两个辅助手段，非muduo.thread的主要功能，也暂不分析。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浅尝kdump+crash</title>
   <link href="http://blog.leezhong.com/linux/2012/07/27/kdump-crash.html"/>
   <updated>2012-07-27T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/linux/2012/07/27/kdump-crash</id>
   <content type="html">&lt;p&gt;kdump是一种内核转储机制，而&lt;a href=&quot;http://people.redhat.com/anderson/&quot;&gt;crash&lt;/a&gt;则是分析转储文件的工具。下文会分析kdump如何实现转储，但crash如何解析转储文件，并从中获取很多有用信息，还不得而知。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;后来发现，本文部分解答了我在“&lt;a href=&quot;http://xanpeng.github.com/linux/2012/04/09/kernel-crash-logging.html&quot;&gt;Kernel Crash Logging and Core Dump&lt;/a&gt;”中的疑惑。&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;kdump&lt;/h3&gt;

&lt;p&gt;先列出kdump的资料：&lt;br/&gt;
1、王聪的“&lt;a href=&quot;http://wangcong.org/blog/wp-content/uploads/2010/12/rh-kdump-2.pdf&quot;&gt;kdump: introduction and overview&lt;/a&gt;”。优点是权威，缺点是简略。&lt;br/&gt;
2、某网友的“&lt;a href=&quot;http://blog.csdn.net/dog250/article/details/5303644&quot;&gt;linux的崩溃转储-kdump的艺术&lt;/a&gt;”。优点是讲述最根本、我最关心的原理，缺点是行文随意，不便阅读。&lt;br/&gt;
3、内核documentation，讲述部分配置细节。&lt;/p&gt;

&lt;p&gt;本文不讲配置使用kdump的详细过程，只是描述原理性的内容，使用细节使用时可查。主要以第2份资料和内部资料（不便公开）为据，并以实验为验证。&lt;/p&gt;

&lt;p&gt;kdump的大致流程：&lt;br/&gt;
1、经过配置，正在运行的系统额外加载一个内核，称之为capture kernel或crash kernel，而对应的正在运行的内核称为primary kernel。这通过在menu.lst中增加crashkernl=x@y，意为将crash kernel加载在y开始的x Mb内存中。&lt;br/&gt;
2、当系统panic时，kdump调用kexec快速启动crash kernel，将panic内核的内存镜像保存在/proc/vmcore下。其中crash kernel是一个单独的内核，被/etc/sysconfig/kdump中的KDUMP_KERNELVER配置。&lt;/p&gt;

&lt;p&gt;疑问：&lt;br/&gt;
1、能不能由panic kernel自己做转储？&lt;br/&gt;
A：primary kernel已经panic，其内部状态和硬件状态是不确定的，此时转储的映像是不可靠的。&lt;br/&gt;
2、为什么crash kernel能做转储？&lt;br/&gt;
A：panic时，系统切换到crash kernel，它能访问整个内存空间。&lt;br/&gt;
3、为crash kernel预留多少内存？&lt;br/&gt;
A：一般是64MB/128MB，内核本身不占多少空间（2M左右），但运行时的内核需占据较多内存。而且，根据第1份资料，x@y的配置不一定总成功，原因不明。&lt;/p&gt;

&lt;h3&gt;crash&lt;/h3&gt;

&lt;p&gt;这个工具用来分析内核转储文件vmcore（&lt;code&gt;crash /path/to/vmlinux vmcore&lt;/code&gt;），也可用gdb，不过&lt;a href=&quot;http://people.redhat.com/anderson/crash_whitepaper/&quot;&gt;crash&lt;/a&gt;更强大。它能看到panic时，&lt;br/&gt;
1、当时的进程（ps）&lt;br/&gt;
2、堆栈信息（bt，bt+pid）&lt;br/&gt;
3、崩溃时的日志（dmesg）&lt;br/&gt;
4、进程打开的文件（files，files+pid）&lt;br/&gt;
5、挂载的FS（mount）&lt;br/&gt;
6、网络（net）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man crash&lt;/code&gt;可以看到更多命令。不过我好奇的是，crash是如何分析vmcore的，做一些猜想：&lt;br/&gt;
1、二者必然遵循格式上的约定，crash从特定位置读取特定信息，这是必然的。&lt;br/&gt;
2、另一个关键问题便是建立地址和symbol的连系，一个配置了CONFIG_DEBUG_INFO的vmlinux是必需的。相信我的博文“&lt;a href=&quot;http://xanpeng.github.com/linux/2012/05/29/linux-kernel-symbols.html&quot;&gt;Linux kernel symbols&lt;/a&gt;”能解释如何建立连系，只是一个查表（“symbol-地址”对应表）的过程。但实际代码如何，尚不得知，不再考究，即便心有惴惴。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>理解boost::bind</title>
   <link href="http://blog.leezhong.com/programming/2012/07/26/boost-bind.html"/>
   <updated>2012-07-26T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/26/boost-bind</id>
   <content type="html">&lt;p&gt;&lt;em&gt;好久没写博，就像已没有了梦想一样（汗！），每天也觉不充实。实是因为最近难得忙，我不得不投入全部心力。今日有阶段性成果，于是晚间拿起放下已久的C++。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;我在看&lt;a href=&quot;http://blog.csdn.net/Solstice/article/details/5829421&quot;&gt;muduo中的C++多线程库&lt;/a&gt;，途中遇到boost::bind技法，陈硕在&lt;a href=&quot;http://blog.csdn.net/Solstice/article/details/3066268&quot;&gt;“以boost::function和boost:bind取代虚函数”&lt;/a&gt;中“高屋建瓴”地探讨其好处，为我现在不能理解。本文打算理解boost::bind，搜寻得到“&lt;a href=&quot;http://blog.csdn.net/hengyunabc/article/details/7773250&quot;&gt;详细解析boost中bind的实现&lt;/a&gt;”，很不错，本文的代码和理解多引自此文。&lt;/p&gt;

&lt;h3&gt;STL bind1st的实现&lt;/h3&gt;

&lt;p&gt;为了区别STL实现，下面例子中都在名字后加上“2”。可以看出bind1st的原理，实际上是把参数保存起来，等到调用时，再取出使用。&lt;br/&gt;
这份代码还是好理解的，你会发现后面的boost::bind代码，会让人崩溃！&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;boost::bind的实现&lt;/h3&gt;

&lt;p&gt;下面的代码是前述博文作者从boost::bind源码中“抠”出来的。先列出main.cc，再列bind.h，你会发现，这代码是妖！&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;理解这段代码，实非易事，如此多的模板使用让人眼花缭乱。从示例代码可以看出，bind记录参数，在调用函数时能灵活地传入参数。但实际上示例代码没有展示bind的真正效力。此处也不追问，且看这段妖码。分功能和语法技巧来分析这段代码。&lt;/p&gt;

&lt;p&gt;功能：通过cout输出跟踪调用路径，能理解bind.h中错综复杂抽象的作用，下面仅截取第一个调用的输出：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;可看出，bind.h仅提供了最多两个参数的bind。首个调用的执行流程：&lt;br/&gt;
1、bind2先构造bind_t对象。&lt;br/&gt;
1.1、先通过list2记录666和_1。&lt;br/&gt;
2、再调用bind_t的operator()。&lt;br/&gt;
2.1、先通过list2记录i1和i2。&lt;br/&gt;
2.2、返回list2 operator()。&lt;br/&gt;
3、执行list2的operator()，即执行f(a[base_type::a1_], a[base_type::a2_])。&lt;/p&gt;

&lt;p&gt;于是此时对于storage1/storage2，list1/list2等有了初步理解，至于其他更多细节，以及细节后面体现的设计理念，非目前力所能及之事，留待升级后解决。&lt;/p&gt;

&lt;p&gt;而对于语法技巧，我有很多疑问需要解决：&lt;br/&gt;
1、private继承的含义。&lt;br/&gt;
2、list2的operator()(type&lt;R&gt;, F&amp;amp; f, A&amp;amp; a, long)定义，为什么long没有变量名？为什么可以l_(type&lt;result_type&gt;(), f_, a, 0)这么调用？&lt;br/&gt;
3、boost::arg/type这样的空类的作用是什么？&lt;br/&gt;
4、构造函数explicit storage1(boost::arg&amp;lt;I&gt;)的参数也只是类型，没有变量名，为什么？而且提供static boost::arg&amp;lt;I&gt; a1_() { return boost::arg&amp;lt;I&gt;(); }的含义是什么？&lt;br/&gt;
5、unwrapper的作用是什么？&lt;br/&gt;
6、很多空类仅包含typedef，含义是什么？&lt;/p&gt;

&lt;p&gt;不打算立即全力解决这些问题，而是继续学习muduo.thread，这些问题随知识积累将逐步解决。&lt;br/&gt;
可以看出，C++模板使用变化万端，整个代码难见C的直白风格，C++程序会有类型体系，变量、函数等都是类型，把这个观点放在心中，十分利于理解代码！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C++实现线程安全的Singleton</title>
   <link href="http://blog.leezhong.com/programming/2012/07/16/cpp-singleton.html"/>
   <updated>2012-07-16T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/16/cpp-singleton</id>
   <content type="html">&lt;p&gt;如何用C++实现线程安全的单例模式(singleton)，本文汇总这方面的讨论，包括DCL(double-checked-locking)、meyers singleton和采用pthread_once()的方案，并最终决定在今后&lt;strong&gt;选择pthread_once()方案&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在现在的我看来，陈硕的muduo是一个宝库，从中可以学到C++、网络编程、分布式应用、多线程服务程序等方面的实践知识。muduo不是朝夕之功，而且其背后隐藏的价值不下于代码本身，陈硕自2008年始就写作了多篇相关博文，很值得学习，比如“&lt;a href=&quot;http://files.cppblog.com/Solstice/multithreaded_server.pdf&quot;&gt;多线程服务器的常用编程模型&lt;/a&gt;”。此文提到了线程安全的Singleton实现，我想到去年曾了解这个话题，这次再遇，打算记录下来。&lt;/p&gt;

&lt;h3&gt;Double-Checked Locking Pattern&lt;/h3&gt;

&lt;p&gt;DCLP不是线程安全的，因为可能有乱序执行的影响，Meyers的&lt;a href=&quot;http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf&quot;&gt;这篇文章&lt;/a&gt;有讨论。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;Meyers Singleton&lt;/h3&gt;

&lt;p&gt;该实现使用了lazy initialization，看起来线程安全，但实际上不是的。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;因为实际上编译器类似于如此处理(看&lt;a href=&quot;http://stackoverflow.com/questions/1661529/is-meyers-implementation-of-singleton-pattern-thread-safe&quot;&gt;这个链接&lt;/a&gt;，里面有不错的扩展资料)：&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;h3&gt;pthread_once()&lt;/h3&gt;

&lt;p&gt;这个方案被stackoverflow上一些人以及陈硕支持，下面的代码来自于陈硕的博文。&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何实现异常处理</title>
   <link href="http://blog.leezhong.com/programming/2012/07/12/exception-handle.html"/>
   <updated>2012-07-12T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/12/exception-handle</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;注意：本文理解多有不当&lt;/strong&gt;，尤其是C++例子中FPE根本就没有被捕获！我最新的思考位于：&lt;a href=&quot;http://xanpeng.github.com/programming/2012/07/31/cpp-exception-handle.html&quot;&gt;理解C++异常处理&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本文讨论程序语言如何实现异常处理, 从而能深刻地理解异常处理. 由于水平和经验不足, 所述多是个人理解, 欢迎交流和共同探讨.&lt;/p&gt;

&lt;p&gt;了解一些资料之后, 发觉异常处理这个话题也很复杂. 比如对于C++, 往下说就是什么时候触发异常, 内核如何处理异常, 如何把异常信息告知程序. 往上说就是, C++ catch并处理异常之后, 是继续执行还是终止执行(&lt;em&gt;参见&lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_handling&quot;&gt;wiki/Exception_handling&lt;/a&gt;上提到的termination semantics和resumption semantics&lt;/em&gt;), 以及如何实现exception-safe的类和方法等.&lt;/p&gt;

&lt;p&gt;内核的处理机制是固定的, 我想它提供了一些API和消息传送机制, 供用户态使用. 如C++要实现异常处理功能, 就需要用到这些API和消息机制. ULK ch4&quot;中断和异常&quot;说, 80x86 CPU发布了大约20种不同的异常, 而内核为每种异常提供了一个专门的处理程序. 这20种异常中, 我们熟悉的有&quot;Divide error&quot;, &quot;Overflow&quot;, &quot;Segmentation Fault&quot;, &quot;Floating point error&quot;.&lt;/p&gt;

&lt;p&gt;异常分&lt;a href=&quot;http://en.wikipedia.org/wiki/Exception_handling&quot;&gt;软件异常和硬件异常&lt;/a&gt;, 我想硬件异常(&lt;em&gt;以ULK ch4为准&lt;/em&gt;)才是最根本的, 对所有编程语言都一致的, 不管编程语言是否处理, 它们都存在那里, 该发生时还是发生. 因此硬件异常属于系统概念. 而软件异常则属于应用层面的概念, 在不同的编程语言间不一致. 比如Java中有FileNotFoundException异常, 但实际上完全可以没有它, 比如没有异常处理的C, 程序通过检查fd判断文件是否打开成功, 据之执行不同的逻辑.&lt;/p&gt;

&lt;p&gt;但C程序中, 如果疏于检查而使得除零发生, 此时触发硬件异常, 由于C没有异常处理机制, 程序此时就会终止. 这是一种不同的策略, C里面广泛地通过参数检查, 通过返回值检查, 通过全局errno检查, 做了很多其他语言-Java, C++等-的&quot;普通&quot;异常处理工作. 但是当严重的异常发生时, 比如segfault和除零, Java等是可以捕捉这些异常, 并让程序继续执行(&lt;em&gt;resumption semantics&lt;/em&gt;). 但C则没有处理, C认为程序已经严重出错, 回天乏术, 不如直接terminate掉.&lt;/p&gt;

&lt;p&gt;当这些真正的异常发生时, C是让程序终止, C++使用的是termination semantic还是resumption sematic呢? 实例表明C++使用的是termination semantics, C++采取这种方式是出于性能考虑, wiki页面有相关讨论. 而Java和Python则使用了resumption semantics(但Iowa State大学的&lt;a href=&quot;http://www.cs.iastate.edu/~tingz/classes/cs342/Fall2010/lectures/handout-17.pdf&quot;&gt;这篇文档&lt;/a&gt;说Java和Python也是termination semantics). 下面给出示例.&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;br/&gt;
有些编程语言提供了异常处理功能, 有些没有. 不管有没有提供, 除零这样的异常是客观存在的, 并且在内核中有对应的处理程序(&lt;em&gt;参考ULK ch4&lt;/em&gt;). 提供了异常处理功能的编程语言可以定义自己的异常类型, 比如FileNotFoundException, 这样的异常只不过是一种上层的辅助策略. 这种辅助策略可以用来简化编程, 不过也会带来额外的问题, 比如&lt;a href=&quot;http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#Exceptions&quot;&gt;google C++项目就不推荐使用异常&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;可以考虑阅读CPython的异常处理实现, 来佐证上面的猜想.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux网络监测</title>
   <link href="http://blog.leezhong.com/linux/2012/07/11/network-monitor.html"/>
   <updated>2012-07-11T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/linux/2012/07/11/network-monitor</id>
   <content type="html">&lt;p&gt;&lt;em&gt;这是一篇记了一半，觉得没料的文章，本想删掉，但还是先放着吧。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cyberciti.biz/faq/network-statistics-tools-rhel-centos-debian-linux/&quot;&gt;Linux Network Statistics Tools / Commands&lt;/a&gt;: nstat, ss, netstat, ifconfig, sar.&lt;/p&gt;

&lt;p&gt;nstat, ss, netstat, ifconfig, ip, sar, iftop, atop&lt;/p&gt;

&lt;h3&gt;网桥&lt;/h3&gt;

&lt;p&gt;关于网桥的IP地址: &lt;a href=&quot;http://wangcong.org/blog/archives/1657&quot;&gt;http://wangcong.org/blog/archives/1657&lt;/a&gt;.&lt;br/&gt;
理解linux网桥: &lt;a href=&quot;http://my.unix-center.net/~lishuai860113/?p=209&quot;&gt;http://my.unix-center.net/~lishuai860113/?p=209&lt;/a&gt;.&lt;br/&gt;
&lt;code&gt;man brctl&lt;/code&gt;:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;An  ethernet bridge is a device commonly used to connect different networks of ethernets together, so that these ethernets will appear as one ethernet to the participants.&lt;/p&gt;

&lt;p&gt;Each of the ethernets being connected corresponds to one physical interface in the bridge. These individual ethernets are  bundled into one bigger ('logical') ethernet, this bigger ethernet corresponds to the bridge network interface.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;现在的理解是, linux中的网桥类似于一个交换机, 不同的网卡可以作为其中的一个端口. 可以用网桥来隔离下层网络结构, 比如通过网桥构建一个业务网络, 这个网络是相对固定的, 其下层的网络变动可以不影响现有的业务网络.&lt;br/&gt;
下面这幅图片, 能帮助理解虚拟环境下网桥的作用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/network-bridge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;ifconfig&lt;/h3&gt;

&lt;p&gt;ifconfig主要被用来做网卡信息的查询, 以及up/down等简单操作. &lt;code&gt;man ifconfig&lt;/code&gt;可以看出, 它还可以在系统用来配置网卡, 不过在新版本内核中, 已经由&lt;code&gt;ip&lt;/code&gt;替代. 不过配置工作不是当下的关注点.&lt;/p&gt;

&lt;p&gt;ifconfig的输出解释:&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;br0: 设备名; link encap: 基本描述; HWaddr: 硬件地址.&lt;br/&gt;
inet addr: 网络ip地址; Bcast: 广播地址; Mask: 子网掩码.&lt;br/&gt;
UP: 网卡已经启用.&lt;br/&gt;
BROADCAST: 支持广播.&lt;br/&gt;
RUNNING: 网卡正在运行.&lt;br/&gt;
MULTICAST: 支持多播.&lt;br/&gt;
MTU: 最大传输单元.&lt;br/&gt;
Metric: 度量值, 用于估算路由成本.&lt;/p&gt;

&lt;p&gt;RX packets: 接收时, 正确的数据包数.&lt;br/&gt;
errors: 接收时, 错误的数据包数.&lt;br/&gt;
dropped: 接收时, 丢弃的数据包数.&lt;br/&gt;
overruns: 接收时, 由于过速丢弃的数据包数.&lt;br/&gt;
frame: 接收时, 由于frame错误而丢弃的数据包数.&lt;/p&gt;

&lt;p&gt;TX packets: 发送时, 正确的数据包数.&lt;br/&gt;
errors: 发送时, 错误的数据包数.&lt;br/&gt;
dropped: 发送时, 丢弃的数据包数.&lt;br/&gt;
overruns: 发送时, 由于过速丢弃的数据包数.&lt;br/&gt;
frame: 发送时, 由于carrier错误而丢弃的数据包数.&lt;/p&gt;

&lt;p&gt;collisions: 冲突信息包的数目.&lt;br/&gt;
txqueuelen: 发送队列的大小, 此处是1000MB.&lt;/p&gt;

&lt;p&gt;RX bytes: 接收的数据量.&lt;br/&gt;
TX bytes: 发送的数据量.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C语言函数原型的重要性</title>
   <link href="http://blog.leezhong.com/programming/2012/07/11/func-prototype-c.html"/>
   <updated>2012-07-11T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/11/func-prototype-c</id>
   <content type="html">&lt;p&gt;本文涉及:&lt;br/&gt;
1. 隐式声明的危害.&lt;br/&gt;
2. gcc的built-in函数.&lt;/p&gt;

&lt;p&gt;这里说的函数原型是function prototype, 也就是函数声明, 是程序告诉gcc函数样貌的一种方式.&lt;br/&gt;
我们知道, 如果在使用函数之前, 没有提供原型声明, 那么gcc只好根据调用掉吗做隐式声明.&lt;br/&gt;
&lt;strong&gt;隐式声明&lt;/strong&gt;是靠不住的, 因为是由gcc根据调用推导出来的, 因而可能和程序员意图不符合. 并且, 最重要地, gcc默认返回值是int类型, 这样可能有严重的后果. 看下面的例子:&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;不使用和使用&lt;code&gt;-Wall&lt;/code&gt;编译选项, 以及执行的结果如下:&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;可以看出, strerror()的隐式声明返回值被认为是int, 但实际上strerror返回的是一个字符串的地址, 在64位机器上, 地址值大小为8个字节, int值大小是4个字节(&lt;em&gt;x86_64是LP-64模型&lt;/em&gt;), 所以strerror()返回时地址值被截断, 产生一个invalid的地址值, 于是必然segfualt.&lt;br/&gt;
解决办法很简单, 通过&lt;code&gt;#include &amp;lt;string.h&amp;gt;&lt;/code&gt;给出显式声明即可.&lt;/p&gt;

&lt;p&gt;再看另一个例子, 同样是没有提供函数原型声明, 只不过这次是malloc()和free().&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;根据上面的思路, 照理说, malloc()在返回时, 真正的地址值要被截断, 然后赋给指针p, 这个值是非法的, 那么下面更改*p就会segfault. 但实际情况并非如此, 至于为什么, 还不得而知.&lt;br/&gt;
不过, 这次编译的warning有些特别:&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;p&gt;亮点在于warning中的&quot;built-in function&quot;, gcc的built-in函数是一些在编译期间就被计算完成的辅助函数, 比如知名的likely()和unlikely(), 它们在编译期间就被替换为特定的处理方式.&lt;br/&gt;
&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc-4.0.3/gcc/Other-Builtins.html&quot;&gt;gcc文档&lt;/a&gt;给出了built-in函数列表. 也可以使用&lt;code&gt;-fno-builtin&lt;/code&gt;取消使用.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>老友, 故事, 博客和计划</title>
   <link href="http://blog.leezhong.com/life/2012/07/09/frd-blog-plan.html"/>
   <updated>2012-07-09T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/life/2012/07/09/frd-blog-plan</id>
   <content type="html">&lt;h3&gt;老友&lt;/h3&gt;

&lt;p&gt;几周来, 都是早晚呆在公司, 晚上和周末也不例外, 公司凉快, 晚上和周末又人少安静, 可以舒服地看自己的书. 但正如下文要说的, 经常&quot;舒服&quot;也不好.&lt;/p&gt;

&lt;p&gt;这周日, 天热, 有点挣扎要不要去赴西巴之约. 略一犹豫之后, 立即拿下主意起身. 顶着烈日, 奔到玉泉, 重温了学校里的幸福日子. 出了象牙塔, 便入了江湖, 我早已不为此事长叹息. 江湖中摸爬滚打, 苦难艰苛, 幸有往事昔人.&lt;/p&gt;

&lt;p&gt;可惜没有吃到小乐惠, 汝妹的!&lt;/p&gt;

&lt;h3&gt;故事&lt;/h3&gt;

&lt;p&gt;近日的连载热剧&amp;lt;天涯明月刀&gt;, 让我不自觉想起古龙的同名作. 该剧或是改编自此书, 我未深究. 看过一集, 实是槽点太多, 以致吐槽无力, 不是我能看的, 断然不能继续忍受.于是看了古龙的&amp;lt;天涯明月刀&gt;, 只是一个中篇, 在一天时间的各种缝隙里边看完了. 风格一如既往地古龙, 它说了一个故事, 傅红雪的腿瘸着, 他的刀法冠绝, 他的心思缜密, 他的往事悲情, 他的境界高远(荣华富贵在其眼中只是粪土), 他维护很久的王孙剑客燕南飞只是一个傀儡.&lt;/p&gt;

&lt;p&gt;根据东野圭吾小说的电视剧正在慢慢放出, 看了第一集, 场景很小, 人物很少, 故而最终结果难逃观众的猜测, 尽管会有一些略显巧妙的细节. 但东野圭吾的故事有很多精品, 改编拍出的电影也不乏经典之作, &amp;lt;嫌疑犯x的献身&gt;便是其中一部, 故事严谨, 演员演技出众, 拍摄和剪辑也恰到好处.&lt;/p&gt;

&lt;p&gt;东野圭吾写的故事多如我看过的其他日本作品, 不浮躁, 透着淡定关怀和人情; 虐心, 正如@蓝色沉淀所说, 里面的人物多有奇惨的往事. 日本的故事很注重描刻人物内心, 所以他们拍出来的恐怖片无比恐怖.&lt;/p&gt;

&lt;h3&gt;博客&lt;/h3&gt;

&lt;p&gt;又被@鸦片鱼bs我的博客不够深入, 仅是罗列. 我又强调一次现在大多只是学习笔记. 但也引起我的思考, 我看了太多, 做得太少了. 这样理解不深, 而且即使写了博客, 仍会忘掉很多. 所以接下来记录的要更偏实践.&lt;/p&gt;

&lt;p&gt;从玉泉赶回来, 网上闲逛, 看到了这个github pages站点&quot;&lt;a href=&quot;http://blog.leezhong.com/&quot;&gt;无网不剩&lt;/a&gt;&quot;, 很精简, 于是打算使用这个模板.&lt;br/&gt;
遇到的问题:&lt;br/&gt;
1. 分类调整. 这个还好办, 只要依照现在的风格重组文章就行了.&lt;br/&gt;
2. 原有分类信息是否有效. 原来每篇post添加的分类还是有效的, 只是原来的tag好像没用了, 不过留着也不影响现在的显示. 打算还是留着, 可能有用.&lt;br/&gt;
3. 文件后缀是否需要从&quot;.md&quot;改到&quot;.textile&quot;. 我事先没有想清楚, 直接用&lt;code&gt;for file in *.md; do mv $file `echo $file | sed 's/\(.*\.\)md/\1textile/'`; done&lt;/code&gt;改掉了. 但后来想Jekyll应该不会通过后缀名来解析文章内容吧.&lt;br/&gt;
4. 旧文章的显示. 这是最大的问题, 旧文章的代码, 链接, 粗体, 斜体等格式都有显示异常的现象, 现在还不知道怎么解决. 保留旧的配置是可以解决问题的, 但这么做很dirty, 整个project dir会很乱. 于是我打算暂缓解决, 先搞清新风格的用法.&lt;br/&gt;
5. 如何在新风格下写文.&lt;/p&gt;

&lt;p&gt;如何在新风格下写文? 根据历史, 我写文最需要的显示功能是:&lt;br/&gt;
1. 正文都是正常字体, 使得整个页面整洁.&lt;br/&gt;
2. 粗体. 少量, 在正常字体上加粗而已.&lt;br/&gt;
3. 链接. 大量, 我会给出很多链接, 以供阅读者继续了解. 链接要求以常规字体, 蓝色显示.&lt;br/&gt;
4. 斜体. 较多量, 要求斜体以灰色淡化显示, 主要用来表示和主题相关但非主题的内容, 我很喜欢用来写吐槽和感想.&lt;br/&gt;
5. 标题(Headings), 少量, 用来分隔子话题.&lt;br/&gt;
6. 代码. 大量, 要求区别显示, 最好能有高亮. 我以前使用gist来高亮代码, 现在打算直接使用JS.&lt;br/&gt;
7. 列表和引用. 少量, 要求区别显示即可.&lt;br/&gt;
8. 断行. 大量使用.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://thresholdstate.com/articles/4312/the-textile-reference-manual&quot;&gt;textile&lt;/a&gt;的写作语法和markdown相比变化较大, 这是我最不愿看到的, 因为会影响原来的121篇博文. 新模板的作者使用textile, 故而此模板应该最兼容textile, 但我的目的是尽量保持原来的markdown语法. 经过尝试, 发现:&lt;br/&gt;
1. 正文. 无需改动.&lt;br/&gt;
2. &lt;strong&gt;粗体&lt;/strong&gt;. 原有&quot;**粗体**&quot;适用, 仅需调整style.&lt;br/&gt;
3. 链接. 原有规则适用, 仅需调整style.&lt;br/&gt;
4. 斜体. 原有&quot;*斜体*&quot;适用, 仅需调整style, 使淡化显示: &lt;em&gt;斜体&lt;/em&gt;.&lt;br/&gt;
5. 标题. textile的&quot;h3.子标题&quot;对应markdown的&quot;###子标题&quot;, 无需改动.&lt;br/&gt;
6. 代码.  代码高亮已经由&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/liquid-extensions&quot;&gt;Pygments&lt;/a&gt;支持了, 原有style.css不好, 使用&lt;a href=&quot;https://raw.github.com/mojombo/tpw/master/css/syntax.css&quot;&gt;这个&lt;/a&gt;.&lt;br/&gt;
7. 列表原有规则适用. 引用原有规则适用. 仅需调整style, 可参考&lt;a href=&quot;http://www.cssnewbie.com/six-ways-style-blockquotes/&quot;&gt;这里&lt;/a&gt;设置引用style.&lt;br/&gt;
8. 两个连续空格断行仍然有效.&lt;/p&gt;

&lt;p&gt;Liquid error: No such file or directory - pygmentize&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;引用示例:&lt;br/&gt;
practice to prominence - 谢霆锋&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;可见, 我不需要切换到textile, 原来的markdown语法依然适用, 不过新模板的style不完全适合markdown, 需要做特定调整.&lt;br/&gt;
因此对旧的博文, 不需要做大的修改, 代码风格是由pre控制的, 只是没有高亮, 显示还是正常的. 现有的问题:&lt;br/&gt;
1. 有一些死链.&lt;br/&gt;
2. 图片死链.&lt;br/&gt;
3. h1, h2这些headings显示不正常.&lt;br/&gt;
这几个问题无伤大雅, 延迟调整.&lt;/p&gt;

&lt;h3&gt;计划&lt;/h3&gt;

&lt;p&gt;前面说到, 我之前在&quot;舒适&quot;地学习, 这样不好, 后面打算多写代码, 并且给每一个任务设一个deadline, 要有压力! &lt;em&gt;曾参加公司程序竞赛, 压力场景下写码, 感觉很爽!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;内容为王, 本博客现在风格简约, 不在3个月内做大幅改动.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>gdb reference</title>
   <link href="http://blog.leezhong.com/programming/2012/07/04/gdb-dive.html"/>
   <updated>2012-07-04T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/04/gdb-dive</id>
   <content type="html">&lt;p&gt;我在&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/05/06/gdb/&quot;&gt;gdb 原理&lt;/a&gt;&quot;和&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/06/30/how-debuggers-work/&quot;&gt;how debuggers work&lt;/a&gt;&quot;大致介绍了gdb的原理. 本文来总结gdb的详细使用, 涉及:&lt;br/&gt;
1. 各种命令.&lt;br/&gt;
2. cheat sheet, 供快速参考.&lt;br/&gt;
3. &quot;高级&quot;用法.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1&gt;cheat-sheets + books&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;http://darkdust.net/files/GDB%20Cheat%20Sheet.pdf&quot;&gt;cheat sheet addr1&lt;/a&gt;(推荐).&lt;br/&gt;
&lt;a href=&quot;http://users.ece.utexas.edu/~adnan/gdb-refcard.pdf&quot;&gt;cheat sheet addr2&lt;/a&gt;.&lt;br/&gt;
&lt;a href=&quot;http://erik.cabetas.com/stuff/debug/gdb-essentials.pdf&quot;&gt;cheat sheet addr3&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sources.redhat.com/gdb/documentation/&quot;&gt;redhat documentation&lt;/a&gt;页面列有gdb的资料:&lt;br/&gt;
1. &lt;a href=&quot;http://sourceware.org/gdb/current/onlinedocs/gdb.pdf.gz&quot;&gt;Debugging With GDB&lt;/a&gt; by RMS.&lt;br/&gt;
2. &lt;a href=&quot;http://sourceware.org/gdb/current/onlinedocs/gdbint.pdf.gz&quot;&gt;GDB Internals&lt;/a&gt; by John Gilmore.&lt;/p&gt;

&lt;p&gt;其他补充资料:&lt;br/&gt;
1. &lt;a href=&quot;http://dirac.org/linux/gdb/&quot;&gt;Peter's gdb tutorial&lt;/a&gt;.&lt;br/&gt;
2. &lt;a href=&quot;http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html&quot;&gt;gdb FAQ&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&quot;Debugging With GDB&quot;的目录&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;(已读) ch4. running programs under gdb&lt;br/&gt;
(已读) ch5. stopping and continuing&lt;br/&gt;
ch6. running programs backward&lt;br/&gt;
ch7. recording inferior's execution and replaying it&lt;br/&gt;
ch8. examining the stack&lt;br/&gt;
ch9. examining source files&lt;br/&gt;
ch10. examining data&lt;br/&gt;
ch11. debugging optimized code&lt;br/&gt;
ch12. c preprocessor macros&lt;br/&gt;
ch13. tracepoints&lt;br/&gt;
ch14. debugging programs that use overlays&lt;br/&gt;
ch15. using gdb with different languages&lt;br/&gt;
ch16. examining the symbol table&lt;br/&gt;
ch17. altering execution&lt;br/&gt;
ch18. gdb files&lt;br/&gt;
ch19. specifying a debugging target&lt;br/&gt;
ch20. debugging remote programs&lt;br/&gt;
ch21. configuration-specific information&lt;br/&gt;
ch22. controlling gdb&lt;br/&gt;
ch23. extending gdb&lt;br/&gt;
ch24.  command interpreters&lt;br/&gt;
ch25. gdb text user interface&lt;br/&gt;
ch26. using gdb under gnu emacs&lt;br/&gt;
ch27. the gdb/mi interface&lt;br/&gt;
ch28. gdb annotations&lt;br/&gt;
ch29. JIT compilation interface&lt;br/&gt;
ch30. in-process agent&lt;br/&gt;
ch31. reporting bugs in gdb&lt;br/&gt;
ch32. command line editing&lt;br/&gt;
ch33. using history interactively&lt;br/&gt;
Appendix A. in memoriam&lt;br/&gt;
Appendix B. formatting documentation&lt;br/&gt;
Appendix C. installing gdb&lt;br/&gt;
Appendix D. maintenance commands&lt;br/&gt;
Appendix E. gdb remote serial protocol&lt;br/&gt;
Appendix F. the gdb agent expression machanism&lt;br/&gt;
Appendix G. target descriptions&lt;br/&gt;
Appendix H. operating system information&lt;br/&gt;
Appendix I. trace file format&lt;br/&gt;
Appendix J. .gdb_index section format&lt;br/&gt;
...&lt;/p&gt;

&lt;hr /&gt;

&lt;h1&gt;RUN programs under gdb&lt;/h1&gt;

&lt;p&gt;在程序执行之前, 可以向程序传递四类信息:&lt;br/&gt;
arguments: run &lt;em&gt;arg1, arg2, ...&lt;/em&gt;, set &lt;em&gt;args ...&lt;/em&gt;, show args.&lt;br/&gt;
environment: path &lt;em&gt;directory&lt;/em&gt;, show paths, show environment [&lt;em&gt;varname&lt;/em&gt;], set environment &lt;em&gt;varname&lt;/em&gt; [&lt;em&gt;=value&lt;/em&gt;], unset environment &lt;em&gt;varname&lt;/em&gt;.&lt;br/&gt;
working dir: cd &lt;em&gt;directory&lt;/em&gt;, pwd.&lt;br/&gt;
input/output: info terminal, run &gt; outfile&lt;/p&gt;

&lt;p&gt;在程序执行之前, 可以设定程序需要的库等:&lt;br/&gt;
set exec-wrapper &lt;em&gt;wrapper&lt;/em&gt;&lt;br/&gt;
show exec-wrapper&lt;br/&gt;
unset exec-wrapper.&lt;/p&gt;

&lt;p&gt;在程序执行之前, 可以设定程序的虚拟地址的random offset机制:&lt;br/&gt;
set/show disable-randomization on/off.&lt;/p&gt;

&lt;p&gt;调试已在执行的进程:&lt;br/&gt;
attach &lt;em&gt;process-id&lt;/em&gt;&lt;br/&gt;
detach&lt;/p&gt;

&lt;p&gt;调试多个进程:&lt;br/&gt;
info inferiors&lt;br/&gt;
inferior &lt;em&gt;infno&lt;/em&gt;&lt;br/&gt;
add-inferior [-copies &lt;em&gt;n&lt;/em&gt;] [-exec &lt;em&gt;executable&lt;/em&gt;]&lt;br/&gt;
clone-inferior [-copies &lt;em&gt;n&lt;/em&gt;] [&lt;em&gt;infno&lt;/em&gt;]&lt;br/&gt;
remove-inferiors &lt;em&gt;infno...&lt;/em&gt;&lt;br/&gt;
detach inferior &lt;em&gt;infno...&lt;/em&gt;&lt;br/&gt;
kill inferior &lt;em&gt;infno...&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;调试多线程:&lt;br/&gt;
info threads [&lt;em&gt;id...&lt;/em&gt;]&lt;br/&gt;
thread &lt;em&gt;threadno&lt;/em&gt;&lt;br/&gt;
thread apply [&lt;em&gt;threadno&lt;/em&gt; | &lt;em&gt;all&lt;/em&gt;] command&lt;br/&gt;
thread name [&lt;em&gt;name&lt;/em&gt;]&lt;br/&gt;
thread find [&lt;em&gt;regexp&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;调试fork出来的子进程:&lt;br/&gt;
set follow-fork-mode [&lt;em&gt;mode&lt;/em&gt;]&lt;br/&gt;
show follow-fork-mode&lt;br/&gt;
set detach-on-fork [&lt;em&gt;mode&lt;/em&gt;]&lt;br/&gt;
show detach-on-fork&lt;br/&gt;
set follow-exec-mode &lt;em&gt;mode (new/same)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;设置&quot;书签(bookmark)&quot;:&lt;br/&gt;
目前只有GNU/Linux支持此功能. GDB能够保存程序状态的snapshot, 称之为checkpoint, 后面可以返回到之前的checkpoint.&lt;br/&gt;
checkpoint&lt;br/&gt;
info checkpoints&lt;br/&gt;
restart &lt;em&gt;checkpoint-id&lt;/em&gt;&lt;br/&gt;
delete checkpoint &lt;em&gt;checkpoint-id&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;breakpoints&lt;/h1&gt;

&lt;p&gt;break &lt;em&gt;location&lt;/em&gt;&lt;br/&gt;
break&lt;br/&gt;
break ... if &lt;em&gt;cond&lt;/em&gt;&lt;br/&gt;
rbreak &lt;em&gt;regex&lt;/em&gt;, 针对functions.&lt;br/&gt;
rbreak &lt;em&gt;file:regex&lt;/em&gt;
tbreak args, 只有效一次.&lt;br/&gt;
info breakpoints/break [&lt;em&gt;n...&lt;/em&gt;]&lt;br/&gt;
disable [&lt;em&gt;breakpoints&lt;/em&gt;] [&lt;em&gt;range...&lt;/em&gt;]&lt;br/&gt;
enable [&lt;em&gt;breakpoints&lt;/em&gt;] [&lt;em&gt;range...&lt;/em&gt;]&lt;br/&gt;
enable [&lt;em&gt;breakpoints&lt;/em&gt;] once &lt;em&gt;range...&lt;/em&gt;&lt;br/&gt;
enable [&lt;em&gt;breakpoints&lt;/em&gt;] count &lt;em&gt;count&lt;/em&gt; &lt;em&gt;range...&lt;/em&gt;&lt;br/&gt;
enable [&lt;em&gt;breakpoints&lt;/em&gt;] delete &lt;em&gt;range...&lt;/em&gt;&lt;br/&gt;
clear [&lt;em&gt;location&lt;/em&gt;]&lt;br/&gt;
delete [&lt;em&gt;breakpoints&lt;/em&gt;] [&lt;em&gt;range...&lt;/em&gt;]&lt;br/&gt;
save breakpoints [&lt;em&gt;filename&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;一些选项:&lt;br/&gt;
show/set breakpoint pending auto/on/off&lt;br/&gt;
set breakpoint auto-hw on/off&lt;br/&gt;
set breakpoint always-inserted auto/on/off&lt;br/&gt;
set breakpoint condition-evaluation host/target/auto&lt;/p&gt;

&lt;h1&gt;watchpoints&lt;/h1&gt;

&lt;p&gt;use a watchpoint to stop execution whenever the value of an expression changes.&lt;br/&gt;
watch [-l|-location] &lt;em&gt;expr&lt;/em&gt; [thread &lt;em&gt;threadnum&lt;/em&gt;] [mask &lt;em&gt;maskvalue&lt;/em&gt;]&lt;br/&gt;
rwatch [-l|-location] &lt;em&gt;expr&lt;/em&gt; [thread &lt;em&gt;threadnum&lt;/em&gt;] [mask &lt;em&gt;maskvalue&lt;/em&gt;], 值被程序读取时break.&lt;br/&gt;
awatch [-l|-location] &lt;em&gt;expr&lt;/em&gt; [thread &lt;em&gt;threadnum&lt;/em&gt;] [mask &lt;em&gt;maskvalue&lt;/em&gt;], 值被程序读取或写入时break.&lt;br/&gt;
info watchpoints [&lt;em&gt;n...&lt;/em&gt;]&lt;/p&gt;

&lt;h1&gt;catchpoints&lt;/h1&gt;

&lt;p&gt;use catchpoints to cause the debugger to stop for certain kinds of program events.&lt;br/&gt;
catch &lt;em&gt;event (throw, catch, exception, exception unhandled, assert, exec, syscall, syacall name | number, fork, vfork, load/unload regexp)&lt;/em&gt;&lt;br/&gt;
tcatch &lt;em&gt;event&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;continuing and stepping&lt;/h1&gt;

&lt;p&gt;fg/continue [&lt;em&gt;ignore-count&lt;/em&gt;]&lt;br/&gt;
step [&lt;em&gt;count&lt;/em&gt;]&lt;br/&gt;
next [&lt;em&gt;count&lt;/em&gt;]&lt;br/&gt;
show/set step-mode [&lt;em&gt;on/off&lt;/em&gt;]&lt;br/&gt;
finish&lt;br/&gt;
until [&lt;em&gt;location&lt;/em&gt;]&lt;br/&gt;
advance &lt;em&gt;location&lt;/em&gt;&lt;br/&gt;
stepi [&lt;em&gt;arg&lt;/em&gt;]&lt;br/&gt;
nexti [&lt;em&gt;arg&lt;/em&gt;]&lt;/p&gt;

&lt;h1&gt;skip&lt;/h1&gt;

&lt;p&gt;skip [&lt;em&gt;linespec&lt;/em&gt;]&lt;br/&gt;
skip function [&lt;em&gt;linespec&lt;/em&gt;]&lt;br/&gt;
skip file [&lt;em&gt;filename&lt;/em&gt;]&lt;br/&gt;
info skip [&lt;em&gt;range&lt;/em&gt;]&lt;br/&gt;
skip delete [&lt;em&gt;range&lt;/em&gt;]&lt;br/&gt;
skip enable/disable [&lt;em&gt;range&lt;/em&gt;]&lt;/p&gt;

&lt;h1&gt;signals&lt;/h1&gt;

&lt;h1&gt;stop/start multi-threaded programs&lt;/h1&gt;

&lt;p&gt;默认模式为all-stop mode, 任何线程stop时, 所有其他线程也stop. 如果你继续执行时, 所有其他线程也继续执行. 但实际上gdb是不能同时single-step所有线程的, 因为线程调度是操作系统决定的, 所以你step了一个线程, 其他线程可能执行了很多步, 并且其他线程可能停在某个语句的中间, 处于一种数据不&quot;完备&quot;的状态.&lt;br/&gt;
在某些操作系统里, 可以通过locking the OS scheduler来修改gdb的默认行为, 可以使只有一个线程能够执行.&lt;br/&gt;
set scheduler-locking &lt;em&gt;mode&lt;/em&gt;, off表示任何线程可以在任何时候执行, on表示只有当前线程能够执行, step是为single-step做的优化, 它能阻止其它线程抢占正在执行单步调试线程的CPU, 从而保证了基本上不会出&quot;意外&quot;.&lt;br/&gt;
show scheduler-locking&lt;/p&gt;

&lt;p&gt;控制所有inferiors(进程?)的所有线程:&lt;br/&gt;
set schedule-multiple &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show schedule-multiple&lt;/p&gt;

&lt;p&gt;对应于all-stop mode的是non-stop mode, 在调试某个线程的时候, 其他线程可以继续自由地执行.&lt;br/&gt;
set non-stop &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show non-stop&lt;/p&gt;

&lt;p&gt;后台执行, 前台执行指gdb需要等待程序stop, 才能提示输入新的指令. 后台执行相反, 相当于asynchronous方式.  &lt;br/&gt;
set target-async &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show target-async&lt;br/&gt;
interrupt [-a], 中断处于后台模式的程序.&lt;/p&gt;

&lt;p&gt;thread-specific breakpoints:&lt;br/&gt;
break &lt;em&gt;linespec&lt;/em&gt; thread &lt;em&gt;threadno&lt;/em&gt;&lt;br/&gt;
break &lt;em&gt;linespec&lt;/em&gt; thread &lt;em&gt;threadno&lt;/em&gt; if ...&lt;/p&gt;

&lt;p&gt;观察者模式, 用以观察程序行为, 不通过更改变量值, 插入断点等方式尝试修改程序状态. gdb提供了变量observer用以方便地控制.&lt;br/&gt;
set observer &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show observer&lt;br/&gt;
set may-write-registers &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show may-write-registers&lt;br/&gt;
set may-write-memory &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show may-write-memory&lt;br/&gt;
set may-insert-breakpoints &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show may-insert-breakpoints&lt;br/&gt;
set may-insert-tracepoints &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show may-insert-tracepoints&lt;br/&gt;
set may-insert-fast-tracepoints &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show may-insert-fast-tracepoints&lt;br/&gt;
set may-interrupt &lt;em&gt;on/off&lt;/em&gt;&lt;br/&gt;
show may-interrupt&lt;/p&gt;

&lt;h1&gt;call stack&lt;/h1&gt;

&lt;p&gt;gdb自动给所有存在的栈帧(stack frame)编号, 从0开始, 0表示innermost的栈帧. 不过某些编译器提供不生成栈帧的编译方式, 如gcc的-fomit-frame-pointer, 这么做的目的是在大量使用库函数的时候节省栈帧的初始化时间. 对此, gdb仅提供有限的支持.&lt;br/&gt;
backtrace&lt;br/&gt;
backtrace &lt;em&gt;n&lt;/em&gt;&lt;br/&gt;
backtrace &lt;em&gt;-n&lt;/em&gt;&lt;br/&gt;
backtrace full [&lt;em&gt;n|-n&lt;/em&gt;]&lt;br/&gt;
set backstrace past-main [&lt;em&gt;on/off&lt;/em&gt;]&lt;br/&gt;
show backstrace past-main&lt;br/&gt;
set backstrace past-entry [&lt;em&gt;on/off&lt;/em&gt;]&lt;br/&gt;
show backstrace past-entry&lt;br/&gt;
set backstrace limit &lt;em&gt;n/0&lt;/em&gt;&lt;br/&gt;
show backstrace limit&lt;/p&gt;

&lt;p&gt;选择栈帧:&lt;br/&gt;
frame &lt;em&gt;n&lt;/em&gt;&lt;br/&gt;
select-frame&lt;br/&gt;
frame &lt;em&gt;addr&lt;/em&gt;&lt;br/&gt;
up &lt;em&gt;n&lt;/em&gt;&lt;br/&gt;
down &lt;em&gt;n&lt;/em&gt;&lt;br/&gt;
up-silently &lt;em&gt;n&lt;/em&gt;&lt;br/&gt;
down-silently &lt;em&gt;n&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;栈帧信息:&lt;br/&gt;
frame&lt;br/&gt;
info frame [&lt;em&gt;addr&lt;/em&gt;]&lt;br/&gt;
info args, 打印当前选择的栈帧的args.&lt;br/&gt;
info locals, 打印当前选择的栈帧的局部变量.&lt;/p&gt;

&lt;h1&gt;源代码&lt;/h1&gt;

&lt;p&gt;list&lt;br/&gt;
list &lt;em&gt;linenum&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;filename:linenum&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;function&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;function:label&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;filename:function&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;label&lt;/em&gt;&lt;br/&gt;
list &lt;strong&gt;*address&lt;/strong&gt;
list &lt;em&gt;first&lt;/em&gt;, &lt;em&gt;last&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;, last&lt;/em&gt;&lt;br/&gt;
list &lt;em&gt;first,&lt;/em&gt;&lt;br/&gt;
list +[&lt;em&gt;offset&lt;/em&gt;]&lt;br/&gt;
list -[&lt;em&gt;offset&lt;/em&gt;]&lt;br/&gt;
set listsize &lt;em&gt;count&lt;/em&gt;&lt;br/&gt;
show listsize&lt;/p&gt;

&lt;p&gt;edit &lt;em&gt;location&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;forward-search/search &lt;em&gt;regexp&lt;/em&gt;&lt;br/&gt;
reverse-search &lt;em&gt;regexp&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;指定源代码目录:&lt;br/&gt;
directory &lt;em&gt;dirname ...&lt;/em&gt;&lt;br/&gt;
directory, 重置到默认值.&lt;br/&gt;
set directories &lt;em&gt;path-list&lt;/em&gt;&lt;br/&gt;
show directories&lt;br/&gt;
set substitute-path &lt;em&gt;from to&lt;/em&gt;&lt;br/&gt;
unset substitute-path [path]&lt;br/&gt;
show substitute-path [path]&lt;/p&gt;

&lt;h1&gt;机器码&lt;/h1&gt;

&lt;p&gt;info line &lt;em&gt;linespec&lt;/em&gt;&lt;br/&gt;
disassemble [&lt;em&gt;start, end|+length&lt;/em&gt;] | [&lt;em&gt;function&lt;/em&gt;]&lt;br/&gt;
disassemble /m [&lt;em&gt;start, end|+length&lt;/em&gt;] | [&lt;em&gt;function&lt;/em&gt;]&lt;br/&gt;
disassemble /r [&lt;em&gt;start, end|+length&lt;/em&gt;] | [&lt;em&gt;function&lt;/em&gt;]&lt;br/&gt;
set disassembly-flavor &lt;em&gt;instruction-set&lt;/em&gt;&lt;br/&gt;
show disassembly-flavor&lt;br/&gt;
set disassemble-next-line&lt;br/&gt;
show disassemble-next-line&lt;/p&gt;

&lt;h1&gt;examining data&lt;/h1&gt;

&lt;p&gt;print &lt;em&gt;expr&lt;/em&gt;&lt;br/&gt;
print &lt;em&gt;/f expr&lt;/em&gt;, f指定输出格式, 可以是x,d,u,o,t,a,c,f,s,r等.&lt;br/&gt;
print *array@len, 打印数组.&lt;/p&gt;

&lt;p&gt;examine mem:&lt;br/&gt;
x/&lt;em&gt;nfu addr&lt;/em&gt;, n: repeat count. f: display format. u: unit size.&lt;br/&gt;
x &lt;em&gt;addr&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;automatic display, 等于把要看的变量等放到一起:&lt;br/&gt;
display&lt;br/&gt;
display expr&lt;br/&gt;
display/&lt;em&gt;fmt expr&lt;/em&gt;&lt;br/&gt;
display/&lt;em&gt;fmt addr&lt;/em&gt;&lt;br/&gt;
undisplay &lt;em&gt;dnums...&lt;/em&gt;&lt;br/&gt;
delete display &lt;em&gt;dnums...&lt;/em&gt;&lt;br/&gt;
disable display &lt;em&gt;dnums...&lt;/em&gt;&lt;br/&gt;
enable display &lt;em&gt;dnums...&lt;/em&gt;&lt;br/&gt;
info display&lt;/p&gt;

&lt;p&gt;打印设置:&lt;br/&gt;
show/set print address [on/off]&lt;br/&gt;
show/set print symbol-filename on/off&lt;br/&gt;
show/set print max-symbolic-offset max-offset&lt;br/&gt;
show/set print symbol on/off&lt;br/&gt;
show/set print array [on/off]&lt;br/&gt;
show/set print array-indexes [on/off]&lt;br/&gt;
show/set print elements number-of-elements&lt;br/&gt;
show/set print frame-arguments value&lt;br/&gt;
show print entry-values&lt;br/&gt;
show/set print repeats&lt;br/&gt;
show/set print null-stop&lt;br/&gt;
show/set print pretty on/off&lt;br/&gt;
show/set print sevenbit-strings on/off&lt;br/&gt;
show/set print union on/off&lt;br/&gt;
show/set print demangle on/off&lt;br/&gt;
show/set print asm-demangle on&lt;br/&gt;
show/set demangle-style &lt;em&gt;style&lt;/em&gt;&lt;br/&gt;
show/set print object on/off&lt;br/&gt;
show/set print static-members on/off&lt;br/&gt;
show/set print &lt;strong&gt;vtbl&lt;/strong&gt; on/off&lt;/p&gt;

&lt;p&gt;pretty-printer:&lt;br/&gt;
info pretty-printer [&lt;em&gt;object-regexp&lt;/em&gt; [&lt;em&gt;name-regexp&lt;/em&gt;]]&lt;br/&gt;
enable/disable pretty-printer [&lt;em&gt;object-regexp&lt;/em&gt; [&lt;em&gt;name-regexp&lt;/em&gt;]]&lt;/p&gt;

&lt;p&gt;和symbol多义有关:&lt;br/&gt;
set multiple-symbols &lt;em&gt;mode(all/ask/cancel)&lt;/em&gt;&lt;br/&gt;
show multiple-symbols&lt;/p&gt;

&lt;h1&gt;debugging optimized code&lt;/h1&gt;

&lt;p&gt;你肯定遇到过&quot;value be optimized&quot;这样的信息, 并有点抓狂. 此时可以设置编译选项取消优化, 并重编译. 但有时你需要调试优化版本, 因为贴近实际情况.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;inline funcitons&lt;/strong&gt;&lt;br/&gt;
inline是对编译器的建议, 可以通过info frame来确定函数是否inlined. 不过即使函数inlined, 仍然可以像普通函数那样去查看其args, 局部变量, 去step/next/finish. 但仍有些限制, 在今后使用中将会发现.
gcc使用DWARF 2格式记录inlining debug信息, gdb仅在使用DWARF 2时才支持inlined function.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tail call frames&lt;/strong&gt;&lt;br/&gt;
A调用B, B在return的时候调用C, 即使用return C()这种代码. 这称之为tail call. optimizing compiler可能会优化这段代码, gdb会看到C的调用者是A. info frame命令可以看到tail call的信息.&lt;/p&gt;

&lt;h1&gt;tracepoints&lt;/h1&gt;

&lt;p&gt;需求: 调试实时应用, 要求extremely low intrusiveness. 如调试在线应用, 调试race conditions等.&lt;br/&gt;
trace &lt;em&gt;location&lt;/em&gt;&lt;br/&gt;
trace &lt;em&gt;location&lt;/em&gt; if &lt;em&gt;cond&lt;/em&gt;&lt;br/&gt;
ftrace &lt;em&gt;location&lt;/em&gt; [if &lt;em&gt;cond&lt;/em&gt;]&lt;br/&gt;
strace &lt;em&gt;location&lt;/em&gt; [if &lt;em&gt;cond&lt;/em&gt;]&lt;br/&gt;
delete tracepoint [&lt;em&gt;num&lt;/em&gt;]
enable/disable tracepoint [&lt;em&gt;num&lt;/em&gt;]&lt;br/&gt;
passcount [&lt;em&gt;n&lt;/em&gt; [&lt;em&gt;num&lt;/em&gt;]]&lt;/p&gt;

&lt;p&gt;trace state variables:&lt;br/&gt;
tvariable $&lt;em&gt;name&lt;/em&gt; [= &lt;em&gt;expression&lt;/em&gt;]&lt;br/&gt;
info tvariables&lt;br/&gt;
delete tvariable [$&lt;em&gt;name&lt;/em&gt; ...]&lt;/p&gt;

&lt;p&gt;tracepoint action lists:&lt;br/&gt;
actions [&lt;em&gt;num&lt;/em&gt;]&lt;br/&gt;
collect [&lt;em&gt;/mods&lt;/em&gt;] &lt;em&gt;expr1, expr2, ...&lt;/em&gt;&lt;br/&gt;
teval &lt;em&gt;expr1, expr2, ...&lt;/em&gt;&lt;br/&gt;
while-stepping &lt;em&gt;n&lt;/em&gt;&lt;br/&gt;
set default-collect &lt;em&gt;expr1, expr2, ...&lt;/em&gt;&lt;br/&gt;
show default-collect&lt;/p&gt;

&lt;p&gt;listing tracepoints:&lt;br/&gt;
info tracepoints [&lt;em&gt;num ...&lt;/em&gt;]&lt;br/&gt;
info static-tracepoint-markers&lt;/p&gt;

&lt;p&gt;start and stop trace experiments:&lt;br/&gt;
tstart&lt;br/&gt;
tstop&lt;br/&gt;
tstatus&lt;br/&gt;
show/set disconnected-tracing &lt;em&gt;on/off&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;tfind start/none/end/-/trace point &lt;em&gt;num&lt;/em&gt;/pc &lt;em&gt;addr&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;examining the symbol table&lt;/h1&gt;

&lt;p&gt;show/set case-sensitive on/off/auto&lt;br/&gt;
info address &lt;em&gt;symbol&lt;/em&gt;&lt;br/&gt;
info symbol &lt;em&gt;addr&lt;/em&gt;&lt;br/&gt;
whatis [&lt;em&gt;arg&lt;/em&gt;]&lt;br/&gt;
ptype [&lt;em&gt;arg&lt;/em&gt;]&lt;br/&gt;
info types [&lt;em&gt;regexp&lt;/em&gt;]&lt;br/&gt;
info scope &lt;em&gt;location&lt;/em&gt;&lt;br/&gt;
info source/sources&lt;br/&gt;
info functions [&lt;em&gt;regexp&lt;/em&gt;]&lt;br/&gt;
info variables [&lt;em&gt;regexp&lt;/em&gt;]&lt;br/&gt;
info classes [&lt;em&gt;regexp&lt;/em&gt;]&lt;br/&gt;
info selectors [&lt;em&gt;regexp&lt;/em&gt;]&lt;br/&gt;
show/set opaque-type-resolution on/off&lt;br/&gt;
maint print symbols/psymbols/msymbols &lt;em&gt;filename&lt;/em&gt;&lt;br/&gt;
maint info symtabs/psymtabs [&lt;em&gt;regexp&lt;/em&gt;]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>debug hacks--debugging skills for application and kernel dev</title>
   <link href="http://blog.leezhong.com/programming/2012/07/03/debug-hacks.html"/>
   <updated>2012-07-03T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/07/03/debug-hacks</id>
   <content type="html">&lt;p&gt;&lt;em&gt;本文是书籍《Debug Hacks中文版-深入调试的技术和工具》的笔记. 这是一本好书, 它介绍了应用程序和内核调试的多方面的技能, 虽然每个点不是非常深入, 但我事先有些许基础, 故而读起来比较畅快! 我给这本书打4.5分, 他是作者数十年经验的传承, 十分珍贵, 然而不足之处在于对于某些工具仅谈其使用, 而不谈其原理. 比如假使在讲述GDB时, 如指出GDB依赖于ptrace()系统调用, 那就完美了!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;本书作者是日本人, 于是加强了我对日本人的好感, 延续了在我眼中勤俭务实的优点. 在IT方面, 除了老美之外, 数TW和日本同行为我尊敬. 我对TW ITer有些了解, 他们的谦谨好学, 在论坛开放的讨论风格为我敬佩, 相比之下, 国内的讨论多有傲慢和怒骂.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;言归正传. &quot;Debug Hacks&quot;和另外一本书&quot;Binary Hacks&quot;类似, 也采用recipes的方式写作, 同样的章节安排形式也见于&quot;Effective C++&quot;等. 碰巧&quot;Binary Hacks&quot;也是日本人写作的, 如其题目, 是介绍binary级别操作的一本书, 由此更可见日本人对基础的夯实态度.&lt;/p&gt;

&lt;p&gt;Debug Hacks分6章中列出了66个话题. 根据平时使用的频率, 我将它们分为&lt;strong&gt;3类调试能力&lt;/strong&gt;:&lt;br/&gt;
1. 常规能力.&lt;br/&gt;
2. 升阶能力.&lt;br/&gt;
3. 神级能力.&lt;br/&gt;
前两种表示常用的技能, 而&quot;神级&quot;则表示少用, 难用, 应用面更具体的技能, 一般了解&quot;神级&quot;之前, 前两级应已掌握, 彼时已神.&lt;/p&gt;

&lt;p&gt;我也不列出所有条目, 而是按照上面的分类大致地概括. 不过TOC本身就是难得的信息, 后续遇到疑问时完全值得再根据TOC参考本书. 本书每个话题的结尾还列出了参考文献, 也是极佳的资料.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;调试的思路和心得是要自己摸索和总结的. 动手之前, 先弄清楚问题场景. 再考虑如何重现, 定位和解决. 这应是通用的基本思路了.&lt;br/&gt;
定位问题时, 我们会做&quot;合理的&quot;猜测, 并做一些验证. 最给力的也被用的最多的就是printf了.&lt;/p&gt;

&lt;h1&gt;保护现场&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;core dump&lt;/strong&gt;&lt;br/&gt;
对于用户进程, 可以设置&lt;a href=&quot;http://en.wikipedia.org/wiki/Core_dump&quot;&gt;内核转储, 即core dump&lt;/a&gt;(&lt;em&gt;将发生问题时进程的内存信息记录下来&lt;/em&gt;), 有了core文件, 就可以马上调试, 查看出错时堆栈的backtrace等. 大多数Linux发行版默认关闭了core dump功能, 可以通过&lt;code&gt;ulimit -c unlimited&lt;/code&gt;(&lt;em&gt;表示不限制core文件大小&lt;/em&gt;)开启, 当错误发生时, 就会自动在当前目录下生成core文件. 当然core文件也可以被配置到专有目录下生成, 通过&lt;a href=&quot;http://stackoverflow.com/questions/2065912/core-dumped-but-core-file-is-not-in-current-directory&quot;&gt;修改/etc/sysctl.conf&lt;/a&gt;可达此目的.&lt;/p&gt;

&lt;p&gt;core dump还有高级用法, 分别是 (a)开启整个系统的core dump 和(b)利用coredump_filter掩码排除进程的共享内存dump, 以防止core文件过大. 这两个用法不细述.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通过网络获取内核信息&lt;/strong&gt;&lt;br/&gt;
kernel故障时, 故障信息可能在重启后消息, 本地也极可能不能登录, 此时如何获取到kernel info? 答案是可以通过网络, 比如通过netconsole可以让printk信息通过UDP发送到远程主机. 比如通过&lt;a href=&quot;http://xanpeng.github.com/2012/04/06/linux-serial-port/&quot;&gt;串口&lt;/a&gt;获取kernel crash info. 有多个程序可利用串口收集crash info, 比如&lt;a href=&quot;http://xanpeng.github.com/2012/04/06/linux-serial-port/&quot;&gt;ipmitool&lt;/a&gt;. 细节不表.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IPMI watchdog timer和NMI watchdog&lt;/strong&gt;&lt;br/&gt;
我对IPMI watchdog timer没有了解, 只是觉得这二者应是同一方面的, 便列在一起.&lt;br/&gt;
但对于NMI watchdog, 我却刚好用过. NMI意为Non Maskable Interrupt, 是不可屏蔽中断的意思, 主要用来检测系统死机, 通常定时器每秒钟产生一定次数的时钟中断(可配置), 但是如果在禁止中断的情况下陷入死循环或者死锁, 定时器处理就无法执行. 但这种情况下, NMI仍可工作, CPU仍能执行NMI处理程序, NMI处理程序就能通过监视定时器中断是否被执行, 如果超过一定时间没有执行, 就认为发生了死机.&lt;/p&gt;

&lt;p&gt;近期我刚好发现了一个内核死锁, 碰巧事先设置了kbox(??), kbox就是使用了NMI, 死锁时NMI汇报了kernel trace, 根据trace信息, 我很快定位到了问题, 原来是某文件系统在某次spinlock时没有关中断.&lt;br/&gt;
因而这个事件之后, 我深刻认识到了运行一个kbox这样的侦测器的重要性.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;kdump&lt;/strong&gt;(&lt;em&gt;升阶能力&lt;/em&gt;)&lt;br/&gt;
用以获取内核崩溃转储. kdump是Linux-2.6.13之后合并进入主线的内核崩溃转储功能, 是非常有用的一个工具, 对它我现在十分陌生, 准备单开一篇讲述.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SysRq&lt;/strong&gt;(&lt;em&gt;神级能力&lt;/em&gt;)&lt;br/&gt;
系统不能响应时, 可以尝试SysRq键, 因为SysRq利用了中断, 不过如果出错代码禁止了中断(&lt;em&gt;比如spin_lock_irqsave()&lt;/em&gt;), 那就没辙了, 只能使用NMI watchdog. SysRq的使用参考&lt;a href=&quot;http://www.thegeekstuff.com/2008/12/safe-reboot-of-linux-using-magic-sysrq-key/&quot;&gt;这篇文档&lt;/a&gt;, 感觉平时用的非常少.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核独有的汇编指令ud2, sti, cli等&lt;/strong&gt;(&lt;em&gt;仙级能力&lt;/em&gt;)&lt;br/&gt;
我是凡人来的嘛.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1&gt;分析&lt;/h1&gt;

&lt;p&gt;我们想尽办法保护程序出错的现场, 尽量收集更多的数据, 其目的就是为分析工作提供更多更全的资料.&lt;br/&gt;
分析和解决问题是调试的目的, 这绝不是一个轻松的工作, 它需要你有广泛的知识面, 并且至少能够理解每个知识点的关键. 你要是使用编程语言的高手, 是算法达人, 懂得内核 -- 总之, 这是一个颇有挑战和成就感的事情!&lt;br/&gt;
同时, 它需要经验, 需要敏感度. 但这两点的前提就是知识面和理解深度.&lt;/p&gt;

&lt;p&gt;以上是关键和前提. 本部分要讲的则偏重于工具的使用, 下面开始.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GDB&lt;/strong&gt;&lt;br/&gt;
GNU Debugger, Linux开发者必须熟悉的一个工具. 它支持断点, 条件断点, 单步调试, backtrace等多种功能. GDB本质上是依赖于ptrace()系统调用和INT 3软中断的, 我在&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/05/06/gdb/&quot;&gt;gdb 原理&lt;/a&gt;&quot;和&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/06/30/how-debuggers-work/&quot;&gt;how debuggers work&lt;/a&gt;&quot;都已说到. 不过GDB功能强大, 远没有使用ptrace()的玩具程序那么简单. 我会单开一篇详细整理GDB的使用. 不过要先提一点: 一定要敢想, 你能想到的, 只要不太飘渺, GDB多已实现了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GDB backtrace&lt;/strong&gt;&lt;br/&gt;
单列于此, 只为了强调它是多么的重要. 细节会在GDB相关的POST中说明.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MALLOC_CHECK_&lt;/strong&gt;&lt;br/&gt;
glibc中有个方便的调试标志MALLOC_CHECK_, 可以利用环境变量进行调试, 探测内存相关库函数(malloc, free等)的错误使用引发的bug, 如内存双重释放等. &lt;code&gt;man malloc&lt;/code&gt; 可以看到这个调试标志的更多信息. 使用方法是 &lt;code&gt;env MALLOC_CHECK_=1 /path/to/prog&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Valgrind&lt;/strong&gt;(&lt;em&gt;升阶能力&lt;/em&gt;)&lt;br/&gt;
说到内存方面的问题, 当然离不开Valgrind. 久闻其名, 但还没有使用过. 可能会单开一篇去细述.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核调试&lt;/strong&gt;&lt;br/&gt;
这不是一个简单的话题. 这方面我的经验非常有限, 我不知道有什么便利的方法. 目前我的做法是根据kernel panic时的串口日志, &lt;strong&gt;查看源码+printk&lt;/strong&gt;搞定, 当然是对于简单的问题, 复杂的问题需要升阶的能力和经验. 比如下面使用的crash工具.&lt;br/&gt;
但我现在略犹豫是否要深入内核, 所以暂缓继续了解这块. -- &lt;em&gt;但实际上, 深入下去也无非如彼...没有什么超难的东西, 只是细节而已, 资料+问询可解决. 可以看我的吐槽文: &quot;&lt;a href=&quot;http://xanpeng.github.com/2012/06/14/doxygen-graphviz/&quot;&gt;用Doxygen+Graphviz生成函数调用图&lt;/a&gt;&quot;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核调试之kprobes&lt;/strong&gt;&lt;br/&gt;
上面说到&quot;查看源码+printk&quot;是良方, 但printk往往需要被多次调整, 从而引起多次重编译, 很不方便. &lt;a href=&quot;http://lwn.net/Articles/132196/&quot;&gt;kprobes&lt;/a&gt;把printk的工作放到内核模块, 提供了很多便利.&lt;br/&gt;
细节在我有使用经验时会单开细述, 此处略谈其原理. kprobes支持在目标点前后&quot;插入&quot;指令, 获得目标点的地址或symbols和我的博文&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/05/29/linux-kernel-symbols/&quot;&gt;Linux kernel symbols&lt;/a&gt;&quot;相关(&lt;em&gt;畅快, 理解无阻碍啊, 虽不保证细节绝对正确&lt;/em&gt;), 而&quot;插入&quot;指令我觉得也不是真正地修改可执行文件, 而是通过中断使得CPU选择执行kprobes代码吧, 这个纯属猜测了. 或者Linux本身就考虑了这种需求, 在现有实现中已有类似于pre-handler, post-handler之类的钩子吧?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核调试之systemtap&lt;/strong&gt;&lt;br/&gt;
systemtap是kprobes创建的工具, 于是其他就暂不用细说了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;内核调试之&lt;a href=&quot;http://people.redhat.com/anderson/&quot;&gt;crash&lt;/a&gt;&lt;/strong&gt;(&lt;em&gt;升阶能力&lt;/em&gt;)&lt;br/&gt;
&lt;code&gt;whatis crash&lt;/code&gt; - &quot;Analyze Linux crash dump data or a live system&quot;.&lt;br/&gt;
如上所述, 我暂不花很多时间了解这个话题, 略过.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;/proc/meminfo, /proc/pid/mem&lt;/strong&gt;(&lt;em&gt;升级能力&lt;/em&gt;)&lt;br/&gt;
可以从这两个地方快速获取进程的内存内容.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>abi of linux</title>
   <link href="http://blog.leezhong.com/programming/2012/06/30/linux-abi.html"/>
   <updated>2012-06-30T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/06/30/linux-abi</id>
   <content type="html">&lt;p&gt;在&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/06/29/cpp-abi/&quot;&gt;binary compatibility in c++&lt;/a&gt;&quot;中, 我提到编译器的abi, 操作系统的abi. 通过&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/06/30/compiler-abi/&quot;&gt;abi of compiler&lt;/a&gt;&quot;我尝试去理解&quot;C++ abi&quot;, &quot;compiler abi&quot;, 目前为止, 理解虽有些混乱, 但大概认为compiler abi和C++ abi所指相同. &lt;em&gt;暂停对这些问题的&quot;冥思&quot;, 担心自己是在纠结&quot;茴&quot;字的几种写法, 希望今后能在实践中得到更深体悟.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;本文试考虑操作系统的abi, 以linux为例.&lt;br/&gt;
在documentation/abi中指出, linux ABI是kernel和userspace之间的interface, 分为四类, 对应四个subdir: stable, testing, obsolete, removed. 举一个例子, 便明了.&lt;br/&gt;
stable下的sysfs-module文件内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;What:       /sys/module
Description:
    The /sys/module tree consists of the following structure:

    /sys/module/MODULENAME
        The name of the module that is in the kernel.  This
        module name will show up either if the module is built
        directly into the kernel, or if it is loaded as a
        dyanmic module.

    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这和前两篇文章的角度又不一样了, 暂不细究. 另看redhat的文档&lt;a href=&quot;http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/6/html/Developer_Guide/lib.compatibility.abi.html&quot;&gt;lib.compatibility.abi&lt;/a&gt;, 其中说明:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;ABI is a set of runtime conventions adhered to by all tools which deal with a compiled binary representation of a program.&lt;/p&gt;

&lt;p&gt;Examples of such tools include compilers, linkers, runtime libraries, and the operating system itself.&lt;/p&gt;

&lt;p&gt;ABI includes not only the binary file formats, but also the semantics of library functions which are used by applications.&lt;/p&gt;&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>how debuggers work</title>
   <link href="http://blog.leezhong.com/programming/2012/06/30/how-debuggers-work.html"/>
   <updated>2012-06-30T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/06/30/how-debuggers-work</id>
   <content type="html">&lt;p&gt;我在0506总结了&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/05/06/gdb/&quot;&gt;gdb 原理&lt;/a&gt;&quot;, 提到了gdb本质上是使用ptrace系统调用. 今天看到国外同行写了一个&quot;how debuggers work&quot;系列, 理解深刻, 表达简明, 6星推荐! 从中可以看出对于debugger来说, ptrace和INT 3(&lt;em&gt;trap to debugger&lt;/em&gt;)软中断居功至伟.&lt;/p&gt;

&lt;p&gt;以下是链接:&lt;br/&gt;
&lt;a href=&quot;http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1/&quot;&gt;part1 - basics&lt;/a&gt;.&lt;br/&gt;
&lt;a href=&quot;http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints/&quot;&gt;part2 - breakpoints&lt;/a&gt;.&lt;br/&gt;
&lt;a href=&quot;http://eli.thegreenplace.net/2011/02/07/how-debuggers-work-part-3-debugging-information/&quot;&gt;part3 - debugging information&lt;/a&gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>abi of compiler</title>
   <link href="http://blog.leezhong.com/programming/2012/06/30/compiler-abi.html"/>
   <updated>2012-06-30T00:00:00+08:00</updated>
   <id>http://blog.leezhong.com/programming/2012/06/30/compiler-abi</id>
   <content type="html">&lt;p&gt;&lt;em&gt;2012-06-30 更新&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在&quot;&lt;a href=&quot;http://xanpeng.github.com/2012/06/29/cpp-abi&quot;&gt;binary compatibility in c++&lt;/a&gt;&quot;中, 我提到C++的二进制兼容性, 提到C++的ABI, 并且提到compiler ABI和操作系统ABI, 本文来讨论compiler ABI.&lt;/p&gt;

&lt;p&gt;那篇文章通过对比&quot;binary compatibility&quot;和&quot;source compatibility&quot;来理解二进制兼容性, 本文来对比API和ABI.&lt;br/&gt;
API大家很熟悉, C++在头文件中描述对外开发的函数的格式, 这就是API. 而ABI跟前篇文章描述的一样, 描述了compiler在编译时所作的特殊处理, 比如使用的alignment和layout等.&lt;/p&gt;

&lt;p&gt;实际上, 我认为G++的compiler abi就是前篇文章描述的C++ abi, 或者C++是没有abi一说的, 编译器才有abi一说. gnu的文档&quot;&lt;a href=&quot;http://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html&quot;&gt;ABI policy and guidelines&lt;/a&gt;&quot;给出了一个式子:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;library API + compiler ABI = library ABI&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;一个插曲: G++的不同版本之间ABI规范是有变更的, 于是使用不同版本G++编译出的library和程序可能不能组合使用. 有一个&lt;a href=&quot;http://abicheck.sourceforge.net/&quot;&gt;ABIcheck&lt;/a&gt;工具可做这方面的检查.&lt;/p&gt;

&lt;p&gt;我在giantchen的&quot;&lt;a href=&quot;http://www.cnblogs.com/Solstice/archive/2011/03/09/1978024.html&quot;&gt;二进制兼容性&lt;/a&gt;&quot;博文作出评论:&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;请问, 本文描述的C++ ABI应该指的就是编译器ABI吧? 比如对于G++来说, 要遵循某个ABI. 而就C++本身是没有ABI一说的吧?&lt;/p&gt;

&lt;p&gt;对于G++ ABI(我参阅这个链接: http://gcc.gnu.org/onlinedocs/libstdc++/manual/abi.html), 我是这么理解的: 输入是C++源码, 处理者是G++, 输出是elf文件, elf是有格式标准的, G++的输出必须遵循这个标准, 但此标准却留有自由度, 对于此自由度, 不同的compiler, 以及同一compiler的不同版本可以有不同的处理方式(也就是所谓convention), 这个特定处理便是 ABI 所关注的了.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;giantchen回复: &quot;理解错误. 这里讲的是库的ABI.&quot;&lt;br/&gt;
又出来一个&quot;库ABI&quot;...但我暂不深究, 我想遇到实际问题时, 我应能知道为什么, 虽然我不知道可将问题划归违背&quot;C++ ABI&quot;, &quot;G++ ABI&quot;或者&quot;库ABI&quot;.&lt;/p&gt;
</content>
 </entry>
 
 
</feed>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>gdb 原理 - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>gdb 原理</h2>
				<div class="cnt">
					<p>我平时使用gdb 时, 使用的大多是基本功能. 就像在 windowns 下使用 vc 的调试器一样, 主要用来做单步跟踪, 验证程序的行为是否与所想一致. 设置断点, 单步执行, 进入函数, 打印变量值, 这就是我们所熟悉的. 然而 gdb 的能力决不仅限于此. 要知晓并利用 gdb 的更多高级能力, 我来思考学习 gdb 的实现原理 ---- 相信这也是很多人好奇的: gdb 以及其他的调试器是如何实现各种调试功能的.</p>

<p>google "gdb principle" 很快得到一些资料:<br/>
<a href="http://www.slideshare.net/libfetion/gdb-principle">gdb 的基本工作原理</a> - 不错的介绍<br/>
<a href="http://www.spongeliu.com/linux/howgdbwork/">gdb 的基本工作原理是什么</a> - 不错的总结<br/>
<a href="http://www.linuxjournal.com/article/6100">play with ptrace, part I</a>, <a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_i/">中译版</a><br/>
<a href="http://www.linuxjournal.com/node/6210/prin">play with ptrace, part II</a>, <a href="http://www.kgdb.info/gdb/playing_with_ptrace_part_ii">中译版</a>
<a href="http://www.slideshare.net/xophiix/gdb-7792796">gdb 实用技巧</a></p>

<div style="width:425px" id="__ss_7569363"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/libfetion/gdb-principle" title="Gdb principle" target="_blank">Gdb principle</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/7569363" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/libfetion" target="_blank">libfetion</a> </div> </div>


<p>其中非常推荐第一个资料, <em>从 url 可以看出作者貌似是 libfetion 的作者, 顺便仰慕一下</em>. 从文中知道 gdb 的下面的内幕:<br/>
+ 分为本地调试器, 远程调试器. 我们先理解本地调试器, 远程调试只不过是在本地调试器加上网络传输.<br/>
+ gdb 基于 ptrace 系统调用.<br/>
+ gdb 调试的基础: 信号.
+ gdb 的三种调试方式: attach 并调试一个已经运行的进程; 运行并调试一个新的进程; 远程调试目标机上新创建的进程.  <br/>
+ gdb 的同步模式和异步模式.<br/>
+ 软件单步和硬件单步.</p>

<h1>ptrace 系统调用</h1>

<p><code>man ptrace</code> 得到:</p>

<blockquote><p>The ptrace() system call provides a means by which a parent process may observe and control the execution of another process, and examine and change its core image and registers. It is primarily used to <strong>implement breakpoint debugging</strong> and <strong>system call tracing</strong>.</p></blockquote>

<p>ptrace 的原型:</p>

<pre><code>long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data);
</code></pre>

<p>request 的值决定将要执行的动作:<br/>
PTRACE_TRACEME: 表示当前进程将被 parent 进程 trace. 所有发送给当前进程的信号(sigkill 除外)都将使得进程停止并通过 wait 通知给 parent.<br/>
PTRACE_PEEKTEXT, PTRACE_PEEKDATA: 读取子进程内存中位置 addr 出的值.<br/>
PTRACE_CONT: 重启停止的子进程.<br/>
...</p>

<h1>信号</h1>

<p><em>更多资料</em></p>

<p>linux kernel debugging site: <a href="http://www.kgdb.info/">http://www.kgdb.info/</a><br/>
linux kernel debugging <a href="http://www.slideshare.net/libfetion/linux-kernel-debugging">slideshare</a></p>

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


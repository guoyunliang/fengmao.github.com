<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>muduo's c++ high-perf logging - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>muduo's c++ high-perf logging</h2>
				<div class="cnt">
					<p><em>接下来我会围绕muduo logging持续更新这一篇博文, 主要涉及c++技法和高性能日志库需要注意的问题.</em></p>

<hr />

<h1>编译muduo</h1>

<p>首先当然要编译, 当然最好依据"官方"文档了: <a href="http://www.chenshuo.com/pdf/MuduoManual.pdf">MuduoManual.pdf</a>. 过程无需细说, 值得注意两点:<br/>
- 代码依平台不同, 可能略有小bug, 阻止编译通过, 很好解决.<br/>
- 默认依赖的工具中有 doxygen, doxygen可能依赖graphviz, 直接编译可能报错, 可以看到脚本里有"cmake --graphviz=file ...", 偷懒的话可直接去除使用doxygen和graphviz.</p>

<hr />

<h1>C++部分</h1>

<p><em>本部分包含代码风格,经验,语法等内容, 我将它们混杂地放在一起.</em></p>

<p><strong>boost</strong><br/>
你会发现, muduo logging使用了很多boost的东西, 关于boost<a href="http://zh.highscore.de/cpp/boost/">这里</a>有一个不错的资料, 是<The Boost C++ Libraries>的中译版.<br/>
boost相关的话题, 由于内容很多, 将新开"<a href="http://xanpeng.github.com/2012/06/22/muduo-boost/">muduo使用的boost</a>"来讨论.</p>

<p><strong>编码风格</strong><br/>
我去年曾了解过<a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">Google C++编码风格</a>, muduo logging的代码用的应该就是这个编码风格, 最突出的特点是内部变量全小写, 并以"_"结尾, 常量以"k"打头, 其余采用驼峰方式.<br/>
初看来, muduo logging的代码看起来赏心悦目, 少量精简必要的注释点缀其间, 其他则由代码"自注释"了.<br/>
整个代码组织和观感非常符合我的审美:)</p>

<p><strong>internal typedefs</strong><br/>
<a href="http://stackoverflow.com/questions/759512/internal-typedefs-in-c-good-style-or-bad-style">Internal typedefs in C++ - good style or bad style?</a>.<br/>
参考muduo::LogStream的代码, 我觉得这样用很直观.</p>

<pre><code>class LogStream : boost::noncopyable
{
    typedef LogStream self;
public:  
    ...
    self&amp; operator&lt;&lt;(short);
    self&amp; operator&lt;&lt;(unsigned short);
    self&amp; operator&lt;&lt;(int);
    self&amp; operator&lt;&lt;(unsigned int);
    self&amp; operator&lt;&lt;(long);
    ...
</code></pre>

<p><strong>用嵌套namespace区分语义和细节</strong><br/>
以LogStream为例, LogStream位于namespace muduo中, 它内部使用了buffer, 用的是detail::FixedBuffer, FixedBuffer属于内部细节, 被放置到namespace muduo::detail中.</p>

<pre><code>class LogStream : boost::noncopyable
{
    typedef LogStream self;
 public:
    typedef detail::FixedBuffer&lt;detail::kSmallBuffer&gt; Buffer;
    ...
</code></pre>

<p><strong>非型别类模板(Nontype Class Template)</strong><br/>
从这个"拗口"的名字你大致可以猜测这是TW同胞的说法了. 不错, 我看的是侯捷大牛等人翻译的&lt;C++ Templates全览>.<br/>
muduo logging使用此物的一个地方是FixedBuffer:</p>

<pre><code>template&lt;int SIZE&gt;
class FixedBuffer : boost::noncopyable
{
    ...
private:
    char data_[SIZE];
    ...
}
</code></pre>

<p>这么做的好处便是, 你可以FixedBuffer<1024>, 也可以FixedBuffer<2048>, 很灵活. 据我去年看书的记忆, FixedBuffer<1024>和FixedBuffer<2048>是不同的两个类型, 是FixedBuffer类型族的两员(<em>我yy的...</em>).<br/>
<em>记得我看书时, 曾看到为什么有模板, 模板的根本局限是什么, 这些问题就留待以后解决吧, 现在是打怪升级刷经验期间, 这些"道"的东西不能现在强悟.</em></p>

<p><strong>函数模板(Function Template)</strong><br/>
在类中使用了函数模板, 和类是否是模板没有关系. 同样, 貌似是有"函数族"的说法的.</p>

<pre><code>template&lt;typename T&gt;
void LogStream::formatInteger(T v)
{
  if (buffer_.avail() &gt;= kMaxNumericSize)
  {
    size_t len = convert(buffer_.current(), v); 
    buffer_.add(len);
  }
}
</code></pre>

<p><strong>使用boost::noncopyable</strong><br/>
在前面的示例代码中可看到noncopyable的踪迹, 这么做的目的是防止用户错误地使用copy-ctor和赋值(一般是错误地使用了编译器提供的copy-ctor, ctor等), 从设计上做严格的限制.<br/>
更多资料:<br/>
- <a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Non-copyable_Mixin">More C++ Idioms/Non-copyable Mixin</a>.<br/>
- Effective C++ 3rd, 条款06:若不想使用编译器自动生成的函数, 就该明确拒绝; 条款14:在资源管理类中小心copying行为.</p>

<p><strong>implicit_cast</strong><br/>
c++有四种类型转换符: static_cast, const_cast, dynamic_cast, reinterpret_cast. 据说implicit_cast本有希望成为第五种的, 但由于提交得太晚, 所以被错过.</p>

<pre><code>// The From type can be inferred, so the preferred syntax for using
// implicit_cast is the same as for static_cast etc.:
//
//   implicit_cast&lt;ToType&gt;(expr)
//
// implicit_cast would have been part of the C++ standard library,
// but the proposal was submitted too late.  It will probably make
// its way into the language in the future.
template&lt;typename To, typename From&gt;
inline To implicit_cast(From const &amp;f) {
  return f;
}
</code></pre>

<p>使用时, 可以这么用:</p>

<pre><code>if (implicit_cast&lt;size_t&gt;(avial()) &gt; len)
</code></pre>

<p>首先这种用法使用了function template argument deduction机制(参考"C++ Templates全览" 2.3), 只指出返回值类型, 参数类型交给编译器去推导.<br/>
其次, implicit_cast的语义是什么? 总的来说, implicit_cast是一个safer, 限制更多的"操作符".<br/>
鉴于c++中类型转换的类型蛮多+我脑残失忆竟不能理解static_cast为何物, 决定新开<a href="http://xanpeng.github.com/2012/06/19/cpp-type-conversion/">一篇post</a>单讲type conversion, 包含了implicit_cast.</p>

<p><strong>template ctor和explicit instantiations</strong><br/>
"<a href="http://stackoverflow.com/questions/3960849/c-template-constructor">C++ template constructor</a>"的accepted answer说, 不方便调用template ctor.</p>

<pre><code>// 定义 @LogStream.h
class Fmt // : boost::noncopyable
{
public:
    template&lt;typename T&gt;
    Fmt(const char* fmt, T val);
    ...
};

// 实现 @LogStream.cc
template&lt;typename T&gt;
Fmt::Fmt(const char* fmt, T val)
{
    BOOST_STATIC_ASSERT(boost::is_arithmetic&lt;T&gt;::value == true);
    length_ = snprintf(buf_, sizeof buf_, fmt, val);
    assert(static_cast&lt;size_t&gt;(length_) &lt; sizeof buf_);
}

// 显示实例化, 可参考&lt;C++ template全览&gt; 6.2节
// Explicit instantiations
template Fmt::Fmt(const char* fmt, char);
template Fmt::Fmt(const char* fmt, short);
template Fmt::Fmt(const char* fmt, unsigned short);
template Fmt::Fmt(const char* fmt, int);
template Fmt::Fmt(const char* fmt, unsigned int);
template Fmt::Fmt(const char* fmt, long);
template Fmt::Fmt(const char* fmt, unsigned long);
template Fmt::Fmt(const char* fmt, long long);
template Fmt::Fmt(const char* fmt, unsigned long long);
template Fmt::Fmt(const char* fmt, float);
template Fmt::Fmt(const char* fmt, double);
</code></pre>

<p><strong>operator as non-member function</strong><br/>
wikibooks "<a href="http://en.wikibooks.org/wiki/C++_Programming/Operators/Operator_Overloading">Operator overloading</a>"列出了操作符重载所有层面的技能点, 如不可重载的操作符, [不]作为member function重载等.<br/>
当operator定义为member func时, 需显式传递的参数可以减少一个, 因为类中都隐含一个this对象, 因此二元操作符只需要指定一个参数, 一元操作符不需要指定参数.<br/>
当operator定义为non-member func时, 需显示传递的第一个参数就是"this"对象.</p>

<pre><code>// as member func
Vector2D Vector2D::operator+(const Vector2D&amp; right) const {...}
// as non-member func
Vector2D operator+(const Vector2D&amp; left, const Vector2D&amp; right) {...}
</code></pre>

<p><strong>为什么</strong>要实现为non-member func? 怎么调用?</p>

<pre><code>// muduo logging中这么使用, 其目的是, LogStream和Fmt是相互独立的两个类, 
// 如果重载为member func, 需要"LogStream&amp; operator&lt;&lt;(const Fmt&amp;)"这么写, 
// 这样增加了LogStream和Fmt的耦合度, 所以实现为non-member func.
inline LogStream&amp; operator&lt;&lt;(LogStream&amp; s, const Fmt&amp; fmt)
{
    s.append(fmt.data(), fmt.length());
    return s;
}

// 调用方式当然是一致的, 要不然怎么算重载呢.
LogStream os;
os &lt;&lt; Fmt("%4.2f", 1.2); // 调用 non-member func
os &lt;&lt; "hello world"; // 调用 member func
</code></pre>

<p><strong>#pragma GCC diagnostic ignored "-Wold-style-cast"</strong><br/>
<a href="http://gcc.gnu.org/onlinedocs/cpp/Pragmas.html">#pragma</a>是用来向compiler提供额外信息的一种方式. 而"<a href="http://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html#Diagnostic-Pragmas">#pragma GCC diagnostic kind option</a>"是gcc提供的机制, 可让用户选择enable/disable某些diagnostics.<br/>
而Wold-style-cast是用以提示c++代码中使用old-style(C-style) cast的, 可以在"<a href="http://gcc.gnu.org/onlinedocs/gcc-3.0.4/gcc_3.html">GCC Command Options</a>"中看到更多gcc选项.<br/>
另外提一个"<a href="http://en.wikipedia.org/wiki/Pragma_once">#pragma once</a>", 它的作用类似于<a href="http://en.wikipedia.org/wiki/Include_guard">include guard</a>.</p>

<hr />

<h1>logging部分</h1>

<p><em>本部分设计的c++技法都放在前面的"c++部分"讲述, 这里仅列出特别的实现策略.</em></p>

<p><a href="http://www.chenshuo.com/pdf/MuduoManual.pdf">MuduoManual.pdf</a>主要是muduo的文档, 而muduo是一个高性能的网络lib, 可能是我接下来的学习目标. 在编译muduo的时候, 根据该manual的链接看到陈硕的博文"<a href="http://blog.csdn.net/Solstice/article/details/5364096">学之者生，用之者死——ACE历史与简评</a>", giantchen行文谨慎, 资料翔实, 论述有据, 认知深刻, 非常推荐. 以后对<a href="http://www.cs.wustl.edu/~schmidt/ACE.html">ACE</a>要谨慎, 同时强烈阻止任何使用它的企图.</p>

<p><strong>FixedBuffer</strong><br/>
这个类最大的疑问是, 为什么有cookie? 什么意思? 有什么用?<br/>
FixedBuffer的设计是简单的: 设置有一个定长数组, 一个游标指针, 一些辅助方法.<br/>
当然有一些不平常的地方:<br/>
- 使用bzero往buffer中写零, 而不是用memset. 搜索得: <a href="http://hi.baidu.com/wg_wang/blog/item/ee41553125c9db1feac4af41.html" title="bzero &amp; memset置零的性能比较">对于小数组, bzero快过memset, memset甚至慢过for(...)</a>, 其原因是<a href="http://fdiv.net/2009/01/14/memset-vs-bzero-ultimate-showdown" title="memset() vs. bzero()-Ultimate Showdown">memset()是逐字节处理的</a>?<br/>
- 提供的append()方法使用memcpy(), 将数据从from拷贝到buffer中.<br/>
- 还提供了一个add()方法, 这个方法只是更新了buffer存放量计数而已, 但在调用add()之前, 用户必须已经往buffer中写入数据, 采用直接操作buffer的方式, 避免了内存拷贝.</p>

<p><strong>LogStream</strong><br/>
初看起来LogStream很普通, 它使用了FixedBuffer, 设置buffer大小为4000字节.<br/>
不平凡之处:<br/>
- typedef LogStream self.<br/>
- 涉及了sprintf和Grisu3 stringify double的问题, 为我原本不知. 搜索得giantchen的"<a href="http://www.cnblogs.com/Solstice/archive/2011/07/17/2108715.html">C++ 工程实践(7)：iostream 的用途与局限</a>", 更是宝藏!</p>

<p><strong>LogStream_bench.cc</strong><br/>
这个函数提供了sprintf, ostringstream和LogStream的性能对比, 称之为bench. <em>原来bench可以是这样简单?</em><br/>
- 对int, double, int64_t, void<em>四种类型数据分别做了1000000次操作, 在64位机器上LogStream的性能一般. </em>不过采用这种bench方案是否合适?*</p>

<p><strong>LogFile</strong><br/>
LogFile代表日志文件, 包含日志文件的操作方法.<br/>
- 底层当然还是由FILE支撑的, 没有什么特别.<br/>
- 提供了rollFile()机制, 由写入日志的条数触发.<br/>
- 提供定期flush机制, 提高效率.<br/>
- rollfile和flush的控制参数都可以通过ctor设置.<br/>
- 为多线程提供了锁定机制, 使用MutexLock, 包装的是pthread_mutex_t.<br/>
- 最终写入文件时调用的是<a href="http://www.kernel.org/doc/man-pages/online/pages/man3/unlocked_stdio.3.html">non-locking stdio functions</a>的fwrite_unlocked(), 应是因为加锁交由LogFile层, stdio层无需再加锁, 以节省时间.<br/>
- LogFile并非单独使用的, 而是被Logger调用的, Logger才是面向用户的界面.</p>

<p><strong>Logger</strong><br/>
顾名思义, 这个类提供用户接口, 实现多线程同步日志功能.<br/>
- 如一般的, 定义了日志级别.<br/>
- 使用LogStream供消息输入, 可知LogStream的buffer是有限的, 所以单行长度是受限的.<br/>
- 使用LogFile将内容写入到文件.<br/>
- 定义LOG_INFO等宏, 如LOG_INFO定义为muduo::Logger(<strong>FILE</strong>, <strong>LINE</strong>).stream().<br/>
- 所以使用方法为: LOG_INFO &lt;&lt; "hello".<br/>
- 通过全局的OutputFunc, FlushFunc函数指针关联LogStream和LogFile, 在Logger的dtor中调用OutputFunc, 如果级别为FATAL, 在dtor中立即调用FlushFunc.<br/>
- OutputFunc, FlushFunc由使用者设置, 默认写到stdout.<br/>
- <strong>特性</strong>: 由于LOG_INFO等定义为宏, 如下面示例代码所示, 如果日志级别不符合, 不需要打印日志, 此时不会带来任何开销.</p>

<pre><code>#define LOG_INFO if (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO) \
      muduo::Logger(__FILE__, __LINE__).stream()
// 使用
LOGINFO &lt;&lt; msg;
// 相当于
if (muduo::Logger::logLevel() &lt;= muduo::Logger::INFO)
      muduo::Logger(__FILE__, __LINE__).stream() &lt;&lt; msg;
</code></pre>

<p>Logger的亮点主要在实现代码上, 代码写的漂亮, 类关系抽象得很好.</p>

<p><strong>MutexLockGuard</strong><br/>
此类的成员MutexLock封装pthread_mutex_t, 这是根本, 毋庸置疑.<br/>
这个类采用的是某种锁设计模式吧, 在ctor中加锁, 在dtor中解锁, 使用时只需要创建MutexLockGuard变量即可.<br/>
这么做的确方便, 而且由"dtor总被调用"来保证unlock, 避免编码遗漏引起的锁异常. 但是语义上把加解锁的动作隐藏起来, 感觉不习惯.</p>

<p><strong>AsyncLogging</strong><br/>
所谓异步日志, 是指并不是在执行LOG_INFO等时就将msg写入文件, 因为写文件耗时长, 会影响主流程的效率.<br/>
<em>在继续写文前, 再次指出, muduo logging的机制和我曾写过的c asynclogger大同小异, 都是采用buffer和后台线程. 但muduo logging优于asynclogger的地方是: 优美的实现代码, giantchen高屋建瓴的总结.</em><br/>
所以, AsyncLogging的做法是: frontend(LOG_INFO等)将消息写到buffer0, buffer0写满时使用buffer1, 并触发后台线程将buffer0的数据写到文件中.<br/>
这些细节都在append()函数中, 当然为了保证时序, 其中是采用MutexLockGuard保护的.<br/>
AsyncLogging和Logger是类似的, 只不过Logger的OutputFunc是直接写文件, 而AsyncLogging的OutputFunc是写buffer0/1的. 其余类似, 不再赘述.</p>

<p><strong>muduo logging总结</strong><br/>
logging部分了解到此, 已无秘密, 剩下的是所使用的c++技法, 将继续更新.<br/>
总结logging, 可以用作者的slide: "<a href="http://www.slideshare.net/chenshuo/efficient-logging-in-multithreaded-c-server/">Efficient logging in multithreaded c++ server</a>". 从中可以看到全面的思路, 强烈推荐! 下面摘取重点:<br/>
- diagnostic log.<br/>
- 去除不必要的, 次要的功能, 只留下最基本也最重要的功能.<br/>
- frontend(LOG_INFO等)要求易用, 低延时. 使用LogStream, 其中使用stack上分配的buffer.<br/>
- 只支持写到本地文件, 通过LogFile实现.<br/>
- log one file for one process.<br/>
- 避免global locking和blocking writing, 采用双buffer, 避免写入buffer和"buffer->disk file"的冲突, 这一点比我的好!<br/>
- 后台线程负责将日志写入文件. 在其中一个buffer满时触发写的动作.</p>

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


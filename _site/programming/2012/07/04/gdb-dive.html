<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>gdb reference - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>gdb reference</h2>
				<div class="cnt">
					<p>我在"<a href="http://xanpeng.github.com/2012/05/06/gdb/">gdb 原理</a>"和"<a href="http://xanpeng.github.com/2012/06/30/how-debuggers-work/">how debuggers work</a>"大致介绍了gdb的原理. 本文来总结gdb的详细使用, 涉及:<br/>
1. 各种命令.<br/>
2. cheat sheet, 供快速参考.<br/>
3. "高级"用法.</p>

<hr />

<h1>cheat-sheets + books</h1>

<p><a href="http://darkdust.net/files/GDB%20Cheat%20Sheet.pdf">cheat sheet addr1</a>(推荐).<br/>
<a href="http://users.ece.utexas.edu/~adnan/gdb-refcard.pdf">cheat sheet addr2</a>.<br/>
<a href="http://erik.cabetas.com/stuff/debug/gdb-essentials.pdf">cheat sheet addr3</a>.</p>

<p><a href="http://sources.redhat.com/gdb/documentation/">redhat documentation</a>页面列有gdb的资料:<br/>
1. <a href="http://sourceware.org/gdb/current/onlinedocs/gdb.pdf.gz">Debugging With GDB</a> by RMS.<br/>
2. <a href="http://sourceware.org/gdb/current/onlinedocs/gdbint.pdf.gz">GDB Internals</a> by John Gilmore.</p>

<p>其他补充资料:<br/>
1. <a href="http://dirac.org/linux/gdb/">Peter's gdb tutorial</a>.<br/>
2. <a href="http://www.unknownroad.com/rtfm/gdbtut/gdbtoc.html">gdb FAQ</a>.</p>

<hr />

<p><strong>"Debugging With GDB"的目录</strong></p>

<p>(已读) ch4. running programs under gdb<br/>
(已读) ch5. stopping and continuing<br/>
ch6. running programs backward<br/>
ch7. recording inferior's execution and replaying it<br/>
ch8. examining the stack<br/>
ch9. examining source files<br/>
ch10. examining data<br/>
ch11. debugging optimized code<br/>
ch12. c preprocessor macros<br/>
ch13. tracepoints<br/>
ch14. debugging programs that use overlays<br/>
ch15. using gdb with different languages<br/>
ch16. examining the symbol table<br/>
ch17. altering execution<br/>
ch18. gdb files<br/>
ch19. specifying a debugging target<br/>
ch20. debugging remote programs<br/>
ch21. configuration-specific information<br/>
ch22. controlling gdb<br/>
ch23. extending gdb<br/>
ch24.  command interpreters<br/>
ch25. gdb text user interface<br/>
ch26. using gdb under gnu emacs<br/>
ch27. the gdb/mi interface<br/>
ch28. gdb annotations<br/>
ch29. JIT compilation interface<br/>
ch30. in-process agent<br/>
ch31. reporting bugs in gdb<br/>
ch32. command line editing<br/>
ch33. using history interactively<br/>
Appendix A. in memoriam<br/>
Appendix B. formatting documentation<br/>
Appendix C. installing gdb<br/>
Appendix D. maintenance commands<br/>
Appendix E. gdb remote serial protocol<br/>
Appendix F. the gdb agent expression machanism<br/>
Appendix G. target descriptions<br/>
Appendix H. operating system information<br/>
Appendix I. trace file format<br/>
Appendix J. .gdb_index section format<br/>
...</p>

<hr />

<h1>RUN programs under gdb</h1>

<p>在程序执行之前, 可以向程序传递四类信息:<br/>
arguments: run <em>arg1, arg2, ...</em>, set <em>args ...</em>, show args.<br/>
environment: path <em>directory</em>, show paths, show environment [<em>varname</em>], set environment <em>varname</em> [<em>=value</em>], unset environment <em>varname</em>.<br/>
working dir: cd <em>directory</em>, pwd.<br/>
input/output: info terminal, run > outfile</p>

<p>在程序执行之前, 可以设定程序需要的库等:<br/>
set exec-wrapper <em>wrapper</em><br/>
show exec-wrapper<br/>
unset exec-wrapper.</p>

<p>在程序执行之前, 可以设定程序的虚拟地址的random offset机制:<br/>
set/show disable-randomization on/off.</p>

<p>调试已在执行的进程:<br/>
attach <em>process-id</em><br/>
detach</p>

<p>调试多个进程:<br/>
info inferiors<br/>
inferior <em>infno</em><br/>
add-inferior [-copies <em>n</em>] [-exec <em>executable</em>]<br/>
clone-inferior [-copies <em>n</em>] [<em>infno</em>]<br/>
remove-inferiors <em>infno...</em><br/>
detach inferior <em>infno...</em><br/>
kill inferior <em>infno...</em></p>

<p>调试多线程:<br/>
info threads [<em>id...</em>]<br/>
thread <em>threadno</em><br/>
thread apply [<em>threadno</em> | <em>all</em>] command<br/>
thread name [<em>name</em>]<br/>
thread find [<em>regexp</em>]</p>

<p>调试fork出来的子进程:<br/>
set follow-fork-mode [<em>mode</em>]<br/>
show follow-fork-mode<br/>
set detach-on-fork [<em>mode</em>]<br/>
show detach-on-fork<br/>
set follow-exec-mode <em>mode (new/same)</em></p>

<p>设置"书签(bookmark)":<br/>
目前只有GNU/Linux支持此功能. GDB能够保存程序状态的snapshot, 称之为checkpoint, 后面可以返回到之前的checkpoint.<br/>
checkpoint<br/>
info checkpoints<br/>
restart <em>checkpoint-id</em><br/>
delete checkpoint <em>checkpoint-id</em></p>

<h1>breakpoints</h1>

<p>break <em>location</em><br/>
break<br/>
break ... if <em>cond</em><br/>
rbreak <em>regex</em>, 针对functions.<br/>
rbreak <em>file:regex</em>
tbreak args, 只有效一次.<br/>
info breakpoints/break [<em>n...</em>]<br/>
disable [<em>breakpoints</em>] [<em>range...</em>]<br/>
enable [<em>breakpoints</em>] [<em>range...</em>]<br/>
enable [<em>breakpoints</em>] once <em>range...</em><br/>
enable [<em>breakpoints</em>] count <em>count</em> <em>range...</em><br/>
enable [<em>breakpoints</em>] delete <em>range...</em><br/>
clear [<em>location</em>]<br/>
delete [<em>breakpoints</em>] [<em>range...</em>]<br/>
save breakpoints [<em>filename</em>]</p>

<p>一些选项:<br/>
show/set breakpoint pending auto/on/off<br/>
set breakpoint auto-hw on/off<br/>
set breakpoint always-inserted auto/on/off<br/>
set breakpoint condition-evaluation host/target/auto</p>

<h1>watchpoints</h1>

<p>use a watchpoint to stop execution whenever the value of an expression changes.<br/>
watch [-l|-location] <em>expr</em> [thread <em>threadnum</em>] [mask <em>maskvalue</em>]<br/>
rwatch [-l|-location] <em>expr</em> [thread <em>threadnum</em>] [mask <em>maskvalue</em>], 值被程序读取时break.<br/>
awatch [-l|-location] <em>expr</em> [thread <em>threadnum</em>] [mask <em>maskvalue</em>], 值被程序读取或写入时break.<br/>
info watchpoints [<em>n...</em>]</p>

<h1>catchpoints</h1>

<p>use catchpoints to cause the debugger to stop for certain kinds of program events.<br/>
catch <em>event (throw, catch, exception, exception unhandled, assert, exec, syscall, syacall name | number, fork, vfork, load/unload regexp)</em><br/>
tcatch <em>event</em></p>

<h1>continuing and stepping</h1>

<p>fg/continue [<em>ignore-count</em>]<br/>
step [<em>count</em>]<br/>
next [<em>count</em>]<br/>
show/set step-mode [<em>on/off</em>]<br/>
finish<br/>
until [<em>location</em>]<br/>
advance <em>location</em><br/>
stepi [<em>arg</em>]<br/>
nexti [<em>arg</em>]</p>

<h1>skip</h1>

<p>skip [<em>linespec</em>]<br/>
skip function [<em>linespec</em>]<br/>
skip file [<em>filename</em>]<br/>
info skip [<em>range</em>]<br/>
skip delete [<em>range</em>]<br/>
skip enable/disable [<em>range</em>]</p>

<h1>signals</h1>

<h1>stop/start multi-threaded programs</h1>

<p>默认模式为all-stop mode, 任何线程stop时, 所有其他线程也stop. 如果你继续执行时, 所有其他线程也继续执行. 但实际上gdb是不能同时single-step所有线程的, 因为线程调度是操作系统决定的, 所以你step了一个线程, 其他线程可能执行了很多步, 并且其他线程可能停在某个语句的中间, 处于一种数据不"完备"的状态.<br/>
在某些操作系统里, 可以通过locking the OS scheduler来修改gdb的默认行为, 可以使只有一个线程能够执行.<br/>
set scheduler-locking <em>mode</em>, off表示任何线程可以在任何时候执行, on表示只有当前线程能够执行, step是为single-step做的优化, 它能阻止其它线程抢占正在执行单步调试线程的CPU, 从而保证了基本上不会出"意外".<br/>
show scheduler-locking</p>

<p>控制所有inferiors(进程?)的所有线程:<br/>
set schedule-multiple <em>on/off</em><br/>
show schedule-multiple</p>

<p>对应于all-stop mode的是non-stop mode, 在调试某个线程的时候, 其他线程可以继续自由地执行.<br/>
set non-stop <em>on/off</em><br/>
show non-stop</p>

<p>后台执行, 前台执行指gdb需要等待程序stop, 才能提示输入新的指令. 后台执行相反, 相当于asynchronous方式.  <br/>
set target-async <em>on/off</em><br/>
show target-async<br/>
interrupt [-a], 中断处于后台模式的程序.</p>

<p>thread-specific breakpoints:<br/>
break <em>linespec</em> thread <em>threadno</em><br/>
break <em>linespec</em> thread <em>threadno</em> if ...</p>

<p>观察者模式, 用以观察程序行为, 不通过更改变量值, 插入断点等方式尝试修改程序状态. gdb提供了变量observer用以方便地控制.<br/>
set observer <em>on/off</em><br/>
show observer<br/>
set may-write-registers <em>on/off</em><br/>
show may-write-registers<br/>
set may-write-memory <em>on/off</em><br/>
show may-write-memory<br/>
set may-insert-breakpoints <em>on/off</em><br/>
show may-insert-breakpoints<br/>
set may-insert-tracepoints <em>on/off</em><br/>
show may-insert-tracepoints<br/>
set may-insert-fast-tracepoints <em>on/off</em><br/>
show may-insert-fast-tracepoints<br/>
set may-interrupt <em>on/off</em><br/>
show may-interrupt</p>

<h1>call stack</h1>

<p>gdb自动给所有存在的栈帧(stack frame)编号, 从0开始, 0表示innermost的栈帧. 不过某些编译器提供不生成栈帧的编译方式, 如gcc的-fomit-frame-pointer, 这么做的目的是在大量使用库函数的时候节省栈帧的初始化时间. 对此, gdb仅提供有限的支持.<br/>
backtrace<br/>
backtrace <em>n</em><br/>
backtrace <em>-n</em><br/>
backtrace full [<em>n|-n</em>]<br/>
set backstrace past-main [<em>on/off</em>]<br/>
show backstrace past-main<br/>
set backstrace past-entry [<em>on/off</em>]<br/>
show backstrace past-entry<br/>
set backstrace limit <em>n/0</em><br/>
show backstrace limit</p>

<p>选择栈帧:<br/>
frame <em>n</em><br/>
select-frame<br/>
frame <em>addr</em><br/>
up <em>n</em><br/>
down <em>n</em><br/>
up-silently <em>n</em><br/>
down-silently <em>n</em></p>

<p>栈帧信息:<br/>
frame<br/>
info frame [<em>addr</em>]<br/>
info args, 打印当前选择的栈帧的args.<br/>
info locals, 打印当前选择的栈帧的局部变量.</p>

<h1>源代码</h1>

<p>list<br/>
list <em>linenum</em><br/>
list <em>filename:linenum</em><br/>
list <em>function</em><br/>
list <em>function:label</em><br/>
list <em>filename:function</em><br/>
list <em>label</em><br/>
list <strong>*address</strong>
list <em>first</em>, <em>last</em><br/>
list <em>, last</em><br/>
list <em>first,</em><br/>
list +[<em>offset</em>]<br/>
list -[<em>offset</em>]<br/>
set listsize <em>count</em><br/>
show listsize</p>

<p>edit <em>location</em></p>

<p>forward-search/search <em>regexp</em><br/>
reverse-search <em>regexp</em></p>

<p>指定源代码目录:<br/>
directory <em>dirname ...</em><br/>
directory, 重置到默认值.<br/>
set directories <em>path-list</em><br/>
show directories<br/>
set substitute-path <em>from to</em><br/>
unset substitute-path [path]<br/>
show substitute-path [path]</p>

<h1>机器码</h1>

<p>info line <em>linespec</em><br/>
disassemble [<em>start, end|+length</em>] | [<em>function</em>]<br/>
disassemble /m [<em>start, end|+length</em>] | [<em>function</em>]<br/>
disassemble /r [<em>start, end|+length</em>] | [<em>function</em>]<br/>
set disassembly-flavor <em>instruction-set</em><br/>
show disassembly-flavor<br/>
set disassemble-next-line<br/>
show disassemble-next-line</p>

<h1>examining data</h1>

<p>print <em>expr</em><br/>
print <em>/f expr</em>, f指定输出格式, 可以是x,d,u,o,t,a,c,f,s,r等.<br/>
print *array@len, 打印数组.</p>

<p>examine mem:<br/>
x/<em>nfu addr</em>, n: repeat count. f: display format. u: unit size.<br/>
x <em>addr</em></p>

<p>automatic display, 等于把要看的变量等放到一起:<br/>
display<br/>
display expr<br/>
display/<em>fmt expr</em><br/>
display/<em>fmt addr</em><br/>
undisplay <em>dnums...</em><br/>
delete display <em>dnums...</em><br/>
disable display <em>dnums...</em><br/>
enable display <em>dnums...</em><br/>
info display</p>

<p>打印设置:<br/>
show/set print address [on/off]<br/>
show/set print symbol-filename on/off<br/>
show/set print max-symbolic-offset max-offset<br/>
show/set print symbol on/off<br/>
show/set print array [on/off]<br/>
show/set print array-indexes [on/off]<br/>
show/set print elements number-of-elements<br/>
show/set print frame-arguments value<br/>
show print entry-values<br/>
show/set print repeats<br/>
show/set print null-stop<br/>
show/set print pretty on/off<br/>
show/set print sevenbit-strings on/off<br/>
show/set print union on/off<br/>
show/set print demangle on/off<br/>
show/set print asm-demangle on<br/>
show/set demangle-style <em>style</em><br/>
show/set print object on/off<br/>
show/set print static-members on/off<br/>
show/set print <strong>vtbl</strong> on/off</p>

<p>pretty-printer:<br/>
info pretty-printer [<em>object-regexp</em> [<em>name-regexp</em>]]<br/>
enable/disable pretty-printer [<em>object-regexp</em> [<em>name-regexp</em>]]</p>

<p>和symbol多义有关:<br/>
set multiple-symbols <em>mode(all/ask/cancel)</em><br/>
show multiple-symbols</p>

<h1>debugging optimized code</h1>

<p>你肯定遇到过"value be optimized"这样的信息, 并有点抓狂. 此时可以设置编译选项取消优化, 并重编译. 但有时你需要调试优化版本, 因为贴近实际情况.</p>

<p><strong>inline funcitons</strong><br/>
inline是对编译器的建议, 可以通过info frame来确定函数是否inlined. 不过即使函数inlined, 仍然可以像普通函数那样去查看其args, 局部变量, 去step/next/finish. 但仍有些限制, 在今后使用中将会发现.
gcc使用DWARF 2格式记录inlining debug信息, gdb仅在使用DWARF 2时才支持inlined function.</p>

<p><strong>tail call frames</strong><br/>
A调用B, B在return的时候调用C, 即使用return C()这种代码. 这称之为tail call. optimizing compiler可能会优化这段代码, gdb会看到C的调用者是A. info frame命令可以看到tail call的信息.</p>

<h1>tracepoints</h1>

<p>需求: 调试实时应用, 要求extremely low intrusiveness. 如调试在线应用, 调试race conditions等.<br/>
trace <em>location</em><br/>
trace <em>location</em> if <em>cond</em><br/>
ftrace <em>location</em> [if <em>cond</em>]<br/>
strace <em>location</em> [if <em>cond</em>]<br/>
delete tracepoint [<em>num</em>]
enable/disable tracepoint [<em>num</em>]<br/>
passcount [<em>n</em> [<em>num</em>]]</p>

<p>trace state variables:<br/>
tvariable $<em>name</em> [= <em>expression</em>]<br/>
info tvariables<br/>
delete tvariable [$<em>name</em> ...]</p>

<p>tracepoint action lists:<br/>
actions [<em>num</em>]<br/>
collect [<em>/mods</em>] <em>expr1, expr2, ...</em><br/>
teval <em>expr1, expr2, ...</em><br/>
while-stepping <em>n</em><br/>
set default-collect <em>expr1, expr2, ...</em><br/>
show default-collect</p>

<p>listing tracepoints:<br/>
info tracepoints [<em>num ...</em>]<br/>
info static-tracepoint-markers</p>

<p>start and stop trace experiments:<br/>
tstart<br/>
tstop<br/>
tstatus<br/>
show/set disconnected-tracing <em>on/off</em></p>

<p>tfind start/none/end/-/trace point <em>num</em>/pc <em>addr</em></p>

<h1>examining the symbol table</h1>

<p>show/set case-sensitive on/off/auto<br/>
info address <em>symbol</em><br/>
info symbol <em>addr</em><br/>
whatis [<em>arg</em>]<br/>
ptype [<em>arg</em>]<br/>
info types [<em>regexp</em>]<br/>
info scope <em>location</em><br/>
info source/sources<br/>
info functions [<em>regexp</em>]<br/>
info variables [<em>regexp</em>]<br/>
info classes [<em>regexp</em>]<br/>
info selectors [<em>regexp</em>]<br/>
show/set opaque-type-resolution on/off<br/>
maint print symbols/psymbols/msymbols <em>filename</em><br/>
maint info symtabs/psymtabs [<em>regexp</em>]</p>

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


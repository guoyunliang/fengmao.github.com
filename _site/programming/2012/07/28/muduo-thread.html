<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>理解muduo.thread - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>理解muduo.thread</h2>
				<div class="cnt">
					<p>迄今为止，我发布的muduo相关文章有：<br/>
1、<a href="http://xanpeng.github.com/programming/2012/06/22/muduo-boost.html">boost in muduo</a> <br/>
2、<a href="http://xanpeng.github.com/programming/2012/06/18/muduo-logging.html">muduo's c++ high-perf logging</a><br/>
迄今为止，我发布的pthreads相关文章有：<br/>
1、<a href="http://xanpeng.github.com/linux/2012/03/28/linux-pthread.html">Linux pthreads 多线程库</a><br/>
2、<a href="http://xanpeng.github.com/linux/2012/05/15/more-linux-pthreads.html">more pthreads</a><br/>
3、<a href="http://xanpeng.github.com/linux/2012/06/15/pthreads-api.html">pthreads--userspace perspective</a></p>

<p>自夸：可以看出认知愈来愈深，文章写作也愈来愈好。现在看来，前文有两大缺点：1、内容不足不深，表述不清。2、自7.9换用新博客模板，旧文布局多有瑕疵。<br/>
这是遗憾，也是必然。</p>

<p>muduo.thread指代muduo中的C++多线程库，陈硕的“<a href="http://blog.csdn.net/Solstice/article/details/5829421">发布一个 Linux 下的 C++ 多线程库</a>”做出简介。<br/>
库的内容：<br/>
1、整数的原子操作，AtomicInt32、AtomicInt64<br/>
2、线程，Thread<br/>
3、线程池，ThreadPool<br/>
4、互斥量和条件变量，MutexLock、Condition、MutexLockGuard<br/>
5、模仿Java concurrent的BlockingQueue和CountdownLatch<br/>
6、Singleton和ThreadLocal</p>

<h3>AtomicInt32，AtomicInt64</h3>

<p>定义于Atomic.h中，分别是模板类AtomicIntegerT的特化，</p>

<blockquote><p>typedef detail::AtomicIntegerT&lt;int32_tAtomicInt32;<br/>
typedef detail::AtomicIntegerT&lt;int64_tAtomicInt64;</p></blockquote>

<p>我平时很少接触到使用AtomicInt的需求，不理解其使用场景。其原子性是通过<a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html">gcc atomic-builtin</a>方法实现的，如：</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<h3>Condition、MutexLock和MutexLockGuard</h3>

<p>muduo用于Linux环境，故而MutexLock、Condition等必然是pthreads的抽象，使之适合C++面向对象语义，使具更优的表达能力。要理解Mutex等，需要理解pthreads，并理解如何抽象才更为合适。</p>

<h4>mutex</h4>

<p>pthreads中的mutex：<br/>
1、变量类型pthread_mutex_t。<br/>
2、初始化，有两种方式：静态PTHREAD_MUTEX_INITIALIZER，动态pthread_mutex_init()。<br/>
3、加锁pthread_mutex_lock()，pthread_mutex_trylock()用的较少。<br/>
4、解锁pthread_mutex_unlock()。<br/>
5、销毁pthread_mutex_destroy()。<br/>
6、attr相关操作。</p>

<p>MutexLock封装pthreads mutex，ctor初始化mutex，dtor销毁mutex，lock()封装pthread_mutex_lock()，unlock则相反。同时，MutexLock还记录mutex的holder。看代码（去除不重要的细节，改变代码排版）：</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<p>MutexLockGuard通过ctor和dtor封装Mutex lock和unlock的调用，避免用户直接调用lock/unlock，预防错误使用。代码很简单：</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<h4>condition</h4>

<p>pthreads中条件变量condition的使用是和mutex天生关联的，多个线程访问共享内存，就某些特定条件需要做出协调时，就需要使用condition。如对公共队列queue，producer和consumer都访问它，producer往其中push，consumer从其中pop，则producer应等待queue非满，consumer需等待queue非空。</p>

<p>对pthreads condition的使用：<br/>
1、变量类型pthread_cond_t。<br/>
2、初始化，PTHREAD_COND_INITIALIZER或pthread_cond_init()。<br/>
3、等待条件满足，pthread_cond_wait(condition, mutex)。这里显示了pthreads中condition和mutex的紧密关联天性，调用前mutex需被加锁，而在wait时，此函数会自动解锁mutex。而当条件满足时——即其他地方调用signal时，此函数会自动加锁mutex，之后程序员需自行负责解锁。<br/>
4、唤醒。有两种方式，pthread_cond_signal()和pthread_cond_broadcast()，后者用于多个线程wait时。<br/>
5、销毁pthread_cond_destroy()。<br/>
6、attr相关操作。</p>

<p>Condition封装pthreads condition，在ctor/dtor中做pthread_cond_init/destroy，提供wait()/notify()/notifyAll()，分别是对pthreads中对应函数的简单封装。Condition类的一个小细节是定义MutexLock&amp;，而非定义MutexLock，因为后者构造一个新的变量，违背语义。</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<h3>Thread</h3>

<p>pthreads中线程的操作：<br/>
1、线程描述符pthread_t。<br/>
2、创建线程pthread_create()。<br/>
3、终止线程pthread_exit()。<br/>
4、join和detach。</p>

<p>Thread封装pthreads基本的线程管理，其中的数据成员有：<br/>
1、线程描述符pthread_t<br/>
2、线程pid_t id<br/>
3、线程的工作函数，为函数指针类型，通过boost::function定义<br/>
4、线程名字<br/>
5、标志线程是否启动的bool started<em><br/>
6、AtomicInt32变量numCreated</em>，保存创建的线程数目</p>

<p>线程是何时开始执行的？想起这个问题时，我楞了一下。线程是创建之后就“立即”执行了——“立即”意为你无需再显示调用pthread_start()之类的函数。所以Thread::start()函数仅仅是封装pthread_create()。列出Thread的函数：<br/>
1、Thread::start()，封装pthread_create()<br/>
2、Thread::join()，封装pthread_join()<br/>
3、线程工作函数func<em>由boost::function定义，由用户传入，但func</em>并不直接传入pthread_create()，而是被startThread做了一层wrap，增加了try-catch保护</p>

<p>所以，Thread是简单的，其亮点之一是boost::function定义线程工作函数，之二是存储了pid——Thread是如何自省得到pid的了？下一小节说明。</p>

<h3>namespace CurrentThread</h3>

<p>CurrentThread是一个namespace，不是一个class。其主要目的是获取当前线程的名字和ID，可以想见是通过系统调用实现的，但非直接调用gettid()，而是调用syscall(SYS_gettid)，这么做应是为避免<a href="http://xanpeng.github.com/linux/2012/05/19/ps-getpid.html">glibc cache</a>。</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<h3>ThreadPool</h3>

<p>顾名思义，将线程放在集合中，形成线程池。好处是节省频繁创建销毁现场的开销、控制线程的数量。<br/>
ThreadPool的主要功能：<br/>
1、定义Thread队列，控制线程数目。<br/>
2、定义任务队列deque<Task>，如果用户高频提交任务，线程池处理不过来，这个队列就会很长。<br/>
3、deque<Task>被MutexLock+Condition保护。</p>

<p>线程终止有<a href="https://computing.llnl.gov/tutorials/pthreads/#CreatingThreads">多种方式</a>，其中之一便是线程顺利完成任务而“自然”退出。于是，这个有一个疑问：ThreadPool的线程必然不能完成一个任务就退出，它们要循环地处理用户提交的Task，对此ThreadPool的实现方法是简单巧妙的：</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<p>然而，ThreadPool又如何正常退出？ThreadPool::stop()通过两个步骤退出：<br/>
1、设置running_=false，使得线程不再从deque<Task>中获取新任务。<br/>
2、等待(join)每一个线程结束。</p>

<p>但还有一个细节：何时调用ThreadPool::stop()？不考虑时机，随意调用stop()，线程池终止时可能还有Task没有完成。<br/>
ThreadPool并不提供策略处理此场景，而由用户在外层自行处理。ThreadPool_test.cc中采用的方案是CountDownLatch，即往deque<Task> push一个countdown任务，此任务完成之后，调用ThreadPool::stop()。用户只要在countdown之后不再push Task即可，便于控制。——这也说明，目前ThreadPool是按FIFO顺序处理任务的，未作其他策略。</p>

<p>下面给出代码，先列出用户代码，用户代码揭示ThreadPool的对外接口，是代码分析入口。为了节省篇幅，下面的代码调整了格式，删除了不紧要内容。从中可以看出boost::function+boost::bind用起来是多么简单优美！</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<p>Liquid error: No such file or directory - pygmentize</p>

<h3>ThreadLocal，BlockQueue，CountDownLatch</h3>

<p>线程局部变量，平时几无接触，暂不分析。BlockQueue、CountDownLatch也只是两个辅助手段，非muduo.thread的主要功能，也暂不分析。</p>

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>了解 Linux 内核 - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>了解 Linux 内核</h2>
				<div class="cnt">
					<p>看过 Greg Kroah-Hartman 的 &lt;<a href="http://www.kroah.com/lkn/">Linux Kernel In a Nutshell</a>> 之后, 发现网络资料的严重弱势, 大牛就是大牛, 将主要细节娓娓道来, 就像讲一个故事. 现在看网络资料, 相比之下它们就是小儿科, 将普普通通的每一个步骤都如临大敌地看待, 让初学者误解, 畏惧, 看不透. 所以:<br/>
<strong>要以权威的书籍等资料作为参考</strong>.</p>

<p>@p4 - 源码放置位置<br/>
The kernel source code should also <strong>nerver</strong> be placed in the <em>/usr/src/linux</em> directory, as that is the location of the kernel that the system libraries were built against, not your custom kernel. Do <strong>not</strong> do any kernel development under the <em>/usr/src/</em> directory tree at all, but only in a local usr directory where nothing bad can happen to the system.</p>

<p>@p5 - 编译工具<br/>
Tools to build the kernel<br/>
+ compiler: <code>gcc --version</code><br/>
+ linker: <code>ld -v</code><br/>
+ make: <code>make --version</code></p>

<p>@p6 - 模块工具<br/>
Tools to use the kernel<br/>
+ util-linux: <code>fdformat --version</code><br/>
+ module-init-tools: <code>depmod -V</code></p>

<p>@p8 - FS 工具<br/>
filesystem-specific tools<br/>
+ ext2/ext3/ext4: <code>tune2fs</code><br/>
+ Quotas: <code>quota -V</code></p>

<p>@p10 - 其他工具<br/>
other tools<br/>
+ udev: <code>udevinfo -V</code><br/>
+ process tools: <code>ps --version</code></p>

<p>@p17 - 配置<br/>
If you have just expanded the kernel source code, there will be <strong>no.config</strong> file, so it needs to be created. It can be created <strong>from scratch</strong>, created <strong>by basing it on the “default configuration”</strong>, taken <strong>from a running kernel version</strong>, or taken <strong>from a distribution kernel release</strong>. <br/>
+ Configure from scratch: <code>make config</code>, 2000+ 选项<br/>
+ Default Configuration Options: <code>make defconfig</code>, 每个内核版本都会有一个 "default" kernel configuration.</p>

<p>有了 .config 之后, 就可以 <code>make menuconfig</code> 做一些修改.</p>

<p>@p26 - <code>make -j</code><br/>
It is best to give a number to the -j option that corresponds to <strong>twice</strong> the number of processors in the system. <code>make -j</code> will create a new thread for every subdirectory in the kernel tree, which can easily cause your machine to become unresponsive and take a much longer time to complete the build.</p>

<p>Build a portion of the kernel: <code>make drivers/usb/serial</code>.</p>

<p>@p30 - 安装<br/>
Almost all distributions come with a script called <em>installkernel</em> that can be used by the kernel build system to automatically install a built kernel into the proper location and modify the bootloader so that nothing extra needs to be done by the developer.</p>

<p><code>make modules_install</code> will install all the modules that you have built and place them in the proper location in the filesystemfor the new kernel to properly find.</p>

<p><code>make install</code> install the main kernel image, will kick off the following process:<br/>
1. The kernel build systemwill verify that the kernel has been successfully built properly.<br/>
2. The build systemwill install the static kernel portion into the/boot directory and name this executable file based on the kernel version of the built kernel.<br/>
3. Any needed initial ramdisk images will be automatically created, using the modules that have just been installed during the <em>modules_install</em> phase.<br/>
4. The bootloader programwill be properly notified that a new kernel is present,and it will be added to the appropriate menu so the user can select it the next time the machine is booted.<br/>
5. After this is finished, the kernel is successfully installed, and you can safely reboot and try out your new kernel image. Note that this installation does <strong>not overwrite </strong>any older kernel images.</p>

<p>@p31 - 安装 Installing by hand.</p>

<p>@p35 - upgrading a kernel</p>

<p>@p45 - /proc/config.gz<br/>
Almost all distributions provide the kernel configuration files as part of the distribution kernel package. Read the distribution-specific documentation for how to find these configurations.<br/>
Most distribu-tion kernels are built to include the configuration within the /proc filesystem.</p>

<p>@p46 - <strong>Find which module is needed</strong>.</p>

<p>@p63-p84 - kernel configuration recipes<br/>
介绍了 config 中每个 option 的含义.</p>

<p>@p87 - Ch9 Kernel boot command-line parameter reference.</p>

<p>@p117 - Ch10 Kernel build command-line reference.</p>

<p>@p122 - Ch11 Kernel configuration option reference.</p>

<hr />

<h1>编译内核</h1>

<p>编译安装Linux内核是每个内核开发者并经的一步了，他们起步的时候都会做这个动作吧，网上也有很多很好的资料，如：<br/>
- <a href="http://www.dedoimedo.com/computers/linux-kernel-compilation.html">How to compile Linux kernel - Tutorial</a><br/>
- <a href="http://www.howtogeek.com/howto/31632/what-is-the-linux-kernel-and-what-does-it-do/">What is the Linux Kernel and What Does It Do?</a><br/>
这篇文章介绍了什么是内核，mocrokernel和Monolithic内核的区别；介绍了Linux Kernel重要的几个文件：vmlinuz，config，initrd，System.map。<br/>
- <a href="http://tuxradar.com/content/how-compile-linux-kernel">How to compile the Linux kernel</a><br/>
这篇文章的特色是，它会告诉你你可以对其他什么文章有兴趣，于是你可以了解更多信息.</p>

<p>王聪大牛的"<a href="http://wangcong.org/blog/archives/240">深入理解Linux内核构建系统（一）</a>"把Makefile中的target简单直白地描述了.其中我比较感兴趣的有<code>make tags</code>和<code>make cscope</code>,不由的让人想<a href="http://ctags.sourceforge.net/">ctags</a>和<a href="http://cscope.sourceforge.net/">cscope</a>和这两个target有什么关系.</p>

<p>1、先准备源代码。</p>

<p>2、make menuconfig    #配置what，who and when will be included in the kernel image。<br/>
配置文件名为“.config”，一般地下载的全新源码中不会包含配置文件。可以使用自己的配置文件，ubuntu/redhat下位于/boot，suse位于/proc/config.gz.</p>

<p>其他可选操作：<br/>
- make oldconfig    <br/>
- make mrproper #clear all pre-compiled binaries and remove .config file.<br/>
- make clean    #just clean all pre-compiled binaries.</p>

<p>3、复杂、严肃的配置过程</p>

<p>4、make all 或者 make &amp;&amp; make modules_install &amp;&amp; make install</p>

<p>5、修改 /boot/grub/menu.lst</p>

<hr />

<h1>编译模块</h1>

<p>内核source tree中的documentation/kbuild/modules.txt说明了如何编译安装内核模块。本文仅摘要关键。</p>

<p>===1、介绍<br/>
kbuild可以拿来编译within-tree(内部模块代码)和out-of-tree(external，外部模块代码)的内核模块代码。内部模块一般是在内核编译安装的过程中，被<code>make modules</code>编译，编译外部模块时，需要的<strong>前提条件</strong>是：提供有预先编译好的完整内核以及源代码(关键是其中的各种.o文件？)。</p>

<p>在修改、调试已有内部模块代码时，也可以当成外部模块来处理。</p>

<p>===2、如何编译<strong>外部模块</strong><br/>
2.1、编译外部模块<br/>
编译(build)</p>

<pre><code># make -C &lt;path-to-kernel&gt; M=\`pwd\`

For the running kernel use:(意思是“编译的模块是打算提供给正在运行的内核”？)
# make -C /lib/modules/\`uname -r\`/build M=\`pwd\`
For the above command to succeed, the kernel must have been built with modules enabled.
</code></pre>

<p>安装(install)</p>

<pre><code># make -C &lt;path-to-kernel&gt; M=\`pwd\` modules_install
</code></pre>

<p>2.2、target介绍(设$KDIR是内核源码的顶层目录)：<br/>
- make -C $KDIR M=`pwd`<br/>
编译模块代码，代码路径是当前目录，编译的所有输出文件也都放在当前目录。<br/>
不会去修改内核源码。<br/>
- make -C $KDIR M=`pwd` modules<br/>
同上，编译模块代码。
- make -C $KDIR M=`pwd` modules_install<br/>
安装外部模块，安装路径默认为/lib/modules/<kernel-version>/<strong>extra</strong>，可以通过INSTALL_MOD_PATH修改。<br/>
- make -C $KDIR M=`pwd` clean<br/>
删除编译模块时生成的所有文件，不会修改kernel代码。<br/>
- make -C $KDIR M=`pwd` help</p>

<p>2.3、可用选项</p>

<p>2.4、<strong>prepare kernel tree</strong> for module build <br/>
modules_prepare用来提供外部模块编译所需要的信息。不过modules_prepare不会编译Module.symvers，即使设置了CONFIG_MODVERSIONS，因此需要完整地编译一次内核，以支持module versioning。</p>

<p>2.5、编译单个文件<br/>
示例（module foo.ko，包含bar.o, baz.o）</p>

<pre><code>make -C $KDIR M=\`pwd\` bar.lst 
make -C $KDIR M=\`pwd\` bar.o
make -C $KDIR M=\`pwd\` foo.ko
make -C $KDIR M=\`pwd\` /
</code></pre>

<p>===3、example commands</p>

<p>===4、creating a kbuild file for an external module</p>

<p>===5、include files</p>

<p>===6、module installation</p>

<p>===7、Module versioning &amp; Module.symvers<br/>
Module versioning is enabled by the CONFIG_MODVERSIONS tag，用来做简单的ABI consistency check。</p>

<p>Module.symvers contains a list of all exported symbols from a kernel build.<br/>
7.1、Symbols from the kernel (vmlinux + modules)<br/>
7.2、Symbols and external modules<br/>
7.3、Symbols from another external module</p>

<p>更多资料：<a href="http://tldp.org/HOWTO/Module-HOWTO/basekerncompat.html">An LKM Must Match The Base Kernel</a></p>

<p>===8、tips &amp; tricks</p>

<hr />

<h1>Q&amp;A</h1>

<p>问题：根据某个kernel源码包编译安装（make &amp;&amp; make modules）模块时，产生错误，dmesg查看得到错误信息“xxxx：no symbol version for module_layout”（xxxx是某模块名）。</p>

<p>答案：</p>

<hr />

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>理解JBD - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>理解JBD</h2>
				<div class="cnt">
					<p>日志（Journal）不是一个陌生的事物，ext3和ext2的主要区别便是ext3引入了日志。ext2没有日志，遇到突然断电之类的，ext2会发生不能启动、某些文件混乱等异常。ext3是有日志的，断电后，可以根据日志恢复，仍旧可用且处于一致状态。</p>

<p>ext3使用的日志功能是由jbd提供的。根据<a href="http://en.wikipedia.org/wiki/Journaling_block_device#Overview">wiki</a>，使用jbd的文件系统并不多：ext3(jbd)，ocfs2(jbd->jbd2)，ext4(jbd2)。为什么这么少的文件系统使用jbd，不得而知，大概是jbd出生太晚，其他文件系统已经“积重难返”吧。</p>

<p>在继续之前需指出，日志只保证一致性，不保证绝无数据丢失。面对同样的硬件和掉电这样的场景，我们没法通过增加软件逻辑去确保万无一失。不过如果有这样的硬件：有备用电源，掉电后立即启用备用电源，使得掉电时的数据仍旧有效，那么或许就不需要日志了。</p>

<p>jbd必须要在磁盘上记录信息，所以ext3的磁盘格式中有一个区域，比如100M大小，专门为日志而留。这个日志区域是定量的，需可重用。因此jbd的工作有：在内存中管理日志、提交日志到磁盘。磁盘上日志空间是有特定格式的，有意思的是日志空间有其superblock，所以可以说是一个小型文件系统。</p>

<h3>原子操作和事务</h3>

<p>jbd使用了两个重要的逻辑抽象：原子操作(handle)和事务(transaction)。handle归属于一个transaction，内存中transaction可以有多个，分为三种：1）已经commit到磁盘，正在执行checkpoint操作的；2）正在将数据提交到日志的；3）正在运行的。正在运行的transaction最多只能有一个（这好理解，因为没必要多个），由它管理随后发生的原子操作。</p>

<p>原子操作很好理解，一件事情要么发生，要么没有发生，不能有中间状态。<br/>
不过这里的原子操作，不是硬件支持的“天生”原子操作，而是由软件逻辑(如加锁)保证的。因此可以调整粒度，比如你可以把写1M作为一个原子操作，也可以把写100M作为一个原子操作。<br/>
如何控制原子操作的粒度才合适？如果FS块大小为1KB，如果把写1M作为原子操作，则其中包括为文件分配1024个数据块，分配若干个索引块，涉及很多块位图操作。整个过程复杂，时间很长，中间出问题的机会很多，因此并不适合作为一个原子操作。<br/>
而为文件分配一个数据块，就适合作为一个原子操作。分配一个数据块，可能需要修改一个inode块、一个磁盘块位图、最多三个间接索引块、block group块、超级块，一共最多7个块。把它作为原子操作，使其要么成功，要么失败，绝不会有中间状态，还是方便控制的。</p>

<p>另外把一个原子操作作为事务处理，效率较低。ext3将多个原子操作组合成一个事务，提高日志读写效率。</p>

<h3>ext3的三种日志模式</h3>

<p>ext3支持三种日志模式：<br/>
1、journal。文件系统所有数据库和元数据块的改变都记入日志。这是最安全，也是最慢的ext3日志模式。<br/>
2、ordered。只对文件系统元数据块的改变才记入日志，这样可以保证文件系统的一致性，但是不能保证文件内容的一致性。不过ext3确保在元数据块写入日志之前，先写入数据库，这样减少文件内数据损坏的机率。这是默认的ext3日志模式。<br/>
3、writeback。和ordered类似，只对元数据改变才记入日志，不过不同于ordered，它对数据块不闻不问，即不会去保证先写数据再写日志。这是最快的模式。</p>

<h3>流程</h3>

<p>日志操作必须是揉合在文件系统操作之中的，才能记录每一个重要细节。以ext3_mkdir()为例，创建一个目录时：<br/>
1、ext3_journal_start()，做文件系统操作之前，先获得handle。transaction处理被封装在其中了<br/>
2、创建和初始化inode<br/>
3、ext3_journal_get_write_access()<br/>
4、更新元数据<br/>
5、ext3_journal_dirty_metadata()<br/>
6、标记inode为脏<br/>
7、ext3_journal_stop()<br/>
8、mkdir完成</p>

<p>上面的API都是在jbd API上的浅层封装。</p>

<p>因此，为一个现成的、没有日志功能的文件系统增加日志功能，实现会很麻烦，会深入原来流程的每个细节。</p>

<h3>transaction lifecycle</h3>

<p>in progress: 正在运行的transaction，管理随后的原子操作，在内存中更新。<br/>
completed：比如transaction用满了，不能再处理后续原子操作，后续原子操作需要新的transaction。这时transaction位于内存中。<br/>
commited：transaction写到磁盘日志空间，标志为commited。如果文件系统异常，可用来replay。<br/>
checkpointed：数据更新被真正地持久化到磁盘上，此时，内存和磁盘日志空间中对应的transaction都是没用的了，需要被删除，以被重复利用。</p>

<p>commit transaction是交给kjournald内核线程做的，两个条件触发commit：定时(5s)和“定量”(比如transaction用满了)。</p>

<h3>总结</h3>

<p>至此，已大致能疏通胸中块垒。</p>

<p>所以jbd的工作可以总结为：在执行文件系统操作时，即时记录日志；日志主要通过事务和原子操作这两大概念管理；日志先由kjournald commit到磁盘，等到文件系统数据也被持久化之后，再删除对应的日志；如果文件系统异常，mount时检查日志，存在的transaction记录没有持久化的数据，据此恢复。</p>

<p>当然，对于jbd，我还有很多问题不明白：<br/>
1、细节。我没有去整理详细的过程。<br/>
2、日志commit之前，会不会数据先写回？这类问题和文件系统、Linux内核缓冲区等基础知识相关，我理解不深，不明白。<br/>
3、jbd2和jbd的区别。</p>

<p>本文参考：Linux源码、<a href="http://cgi.cse.unsw.edu.au/~cs3231/12s1/lectures/lect11x6.pdf">大学讲义</a>、<a href="http://blogimg.chinaunix.net/blog/upfile2/101018213331.pdf">网友(pwp.cublog.cn)的JBD源码分析</a>。</p>

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


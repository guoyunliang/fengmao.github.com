<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<title>printk 级别控制 - xanpeng</title>
		<link rel="stylesheet" type="text/css" href="/css/style.css" />
		<link rel="stylesheet" type="text/css" href="/css/syntax.css" />
	</head>

	<body>
		<div id="wrapper">
			<div id="content">
				<h2>printk 级别控制</h2>
				<div class="cnt">
					<p><a href="http://www.makelinux.net/ldd3/chp-4-sect-2">Debugging by Printing</a></p>

<p>printk 用来打印内核日志, 它的用法举例:</p>

<pre><code>printk(KERN_DEBUG "Here I am: %s:%i\n", _ _FILE_ _, _ _LINE_ _);
printk(KERN_CRIT "I'm trashed; giving up on %p\n", ptr);
</code></pre>

<p>有 8 个日志级别(loglevel, priority), 定义于 &lt;linux/kernel.h> 中,</p>

<pre><code>#define KERN_EMERG  "&lt;0&gt;"   /* system is unusable           */
#define KERN_ALERT  "&lt;1&gt;"   /* action must be taken immediately */
#define KERN_CRIT   "&lt;2&gt;"   /* critical conditions          */
#define KERN_ERR    "&lt;3&gt;"   /* error conditions         */
#define KERN_WARNING    "&lt;4&gt;"   /* warning conditions           */
#define KERN_NOTICE "&lt;5&gt;"   /* normal but significant condition */
#define KERN_INFO   "&lt;6&gt;"   /* informational            */
#define KERN_DEBUG  "&lt;7&gt;"   /* debug-level messages         */
</code></pre>

<p>没有指定级别的 printk 使用 DEFAULT_MESSAGE_LOGLEVEL,</p>

<pre><code>@ kernel/prink.c
/* printk's without a loglevel use this.. */
#define DEFAULT_MESSAGE_LOGLEVEL 4 /* KERN_WARNING */
</code></pre>

<p>根据设定的级别, printk 可能将日志打印到 console, serial port, parallel printer.</p>

<p>如果 loglevel &lt; console_level, 日志一次一行地被发到 console (由 trailing newline 触发). console_level 初始化为 DEFAULT_CONSOLE_LOGLEVEL, 可以被 sys_syslog 系统调用修改.</p>

<pre><code>@ kernel/prink.c
/* We show everything that is MORE important than this.. */
#define MINIMUM_CONSOLE_LOGLEVEL 1 /* Minimum loglevel we let people use */
#define DEFAULT_CONSOLE_LOGLEVEL 7 /* anything MORE serious than KERN_DEBUG */    
</code></pre>

<p>如果 klogd 和 syslogd 都在运行, kernel messages 写到 /var/log/messages 的末尾, 不受 console_level 控制.</p>

<p>如果 klogd 不在运行, 日志不会发送到 userland, 除非用户主动读取 /proc/kmsg (一般通过 dmesg).</p>

<p>使用 klogd 时需要注意, 它不记录连续相等的日志, 只记录第一个不同的行和重复次数.</p>

<p><strong>修改级别</strong></p>

<p>我们一般通过读写 /proc/sys/kernel/printk 控制 printk 级别, 这个文件包含 4 个值: current loglevel, 不指定级别时的 default level, the minimum allowed loglevel, the boot-time default loglevel.</p>

<pre><code># cat /proc/sys/kernel/printk
3       4       1       7
</code></pre>

<p>写入一个数值, 修改的是 current loglevel,</p>

<pre><code># echo 8 &gt; /proc/sys/kernel/printk
</code></pre>

<p><strong>more...</strong></p>

<p><em>redirecting console messages</em></p>

<p>使用 ioctl(TIOCLINUX) 选择接收日志的 virtual terminal.</p>

<p><em>how messages get logged</em></p>

<p>printk 将消息写入大小为 __LOG_BUF_LEN(4KB~1MB) 的 ring buffer, 写入后 wakeup 等待消息的进程:
+ 在 syslog 系统调用中睡眠的进程 - syslog 可以选择将 logdata 留在那里给其他进程.<br/>
+ 正在读取 /proc/kmsg 的进程 - consume data from the log buffer.</p>

<p>如果 klogd 进程在运行, 它获取 kernel messages 然后分发到 syslogd, syslogd 通过查看 /etc/syslog.conf 确定如何处理消息.<br/>
如果 klogd 不在执行, 消息驻留在 ring buffer 中, 直到有人读取或者 buffer overflow.</p>

<p><em>turning the messages on and off</em><br/>
<em>rate limiting</em><br/>
<em>printing device numbers</em></p>

					--EOF--
				</div>
				<div id="disqus_thread"></div>
				<script type="text/javascript">
				  (function() {
				   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				   dsq.src = 'http://xanpeng.disqus.com/embed.js';
				   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				  })();
				</script>
				<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=lzyyblog">comments powered by Disqus.</a></noscript>
			</div>
	</body>
</html>


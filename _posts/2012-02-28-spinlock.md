---
title: spin lock
layout: post
tags: spinlock linux lock
category: programming
---

wikipedia 上对 [spinlock](http://en.wikipedia.org/wiki/Spinlock) 做了不错的解说. 此处做一些摘引.
> * 在线程编程中, spinlock 是这样的一种 lock, 线程循环地等待(spins)加锁, 直到 lock available.  
> * 可知, spinlock 属于 [busy waiting](http://en.wikipedia.org/wiki/Busy_waiting).  
> * spinlock 更适合执行时间短的任务, 因此能够避免操作系统进程调度和 context 切换的时间. 对于执行时间较长的任务, spinlock 的效率可能很低, 因为在线程被调度出 CPU 的时候, spinlock 并不能被其他要求进入同一 critical section 的线程获得.  
> * 正确实现 spinlock 机制不是一件容易的事情, 一般来说, spinlock 只能方便地由特殊的汇编指令(如原子性的 test-and-set 指令)实现.

[冠诚](http://guancheng.42qu.com/) 在他的博文 ["pthreads 并行编程之 spin lock 与 mutex 性能对比分析"](http://www.parallellabs.com/2010/01/31/pthreads-programming-spin-lock-vs-mutex-performance-analysis/) 中详细比较了 mutex (sleep-waiting) 和 spinlock (busy-waiting) 的性能, 他的总结是:
> 1. Mutex适合对锁操作非常频繁的场景，并且具有更好的适应性。尽管相比spin lock它会花费更多的开销（主要是上下切换），但是它能适合实际开发中复杂的应用场景，在保证一定性能的前提下提供更大的灵活度.  
> 2. spin lock的lock/unlock性能更好(花费更少的cpu指令)，但是它只适应用于临界区运行时间很短的场景。而在实际软件开发中，除非程序员对自己的程序的锁操作行为非常的了解，否则使用spin lock不是一个好主意(通常一个多线程程序中对锁的操作有数以万次，如果失败的锁操作(contended lock requests)过多的话就会浪费很多的时间进行空等待).  
> 3. 更保险的方法或许是先（保守的）使用 Mutex，然后如果对性能还有进一步的需求，可以尝试使用spin lock进行调优。毕竟我们的程序不像Linux kernel那样对性能需求那么高(Linux Kernel最常用的锁操作是spin lock和rw lock).

linux 中的 [spinlock](http://www.mjmwired.net/kernel/Documentation/spinlocks.txt).
